"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/barcode-detector";
exports.ids = ["vendor-chunks/barcode-detector"];
exports.modules = {

/***/ "(ssr)/./node_modules/barcode-detector/dist/es/index.js":
/*!********************************************************!*\
  !*** ./node_modules/barcode-detector/dist/es/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BarcodeDetector: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__.BarcodeDetector),\n/* harmony export */   ZXING_CPP_COMMIT: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__.ZXING_CPP_COMMIT),\n/* harmony export */   ZXING_WASM_SHA256: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__.ZXING_WASM_SHA256),\n/* harmony export */   ZXING_WASM_VERSION: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__.ZXING_WASM_VERSION),\n/* harmony export */   prepareZXingModule: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__.prepareZXingModule),\n/* harmony export */   purgeZXingModule: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__.purgeZXingModule),\n/* harmony export */   setZXingModuleOverrides: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__.setZXingModuleOverrides)\n/* harmony export */ });\n/* harmony import */ var _polyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polyfill.js */ \"(ssr)/./node_modules/barcode-detector/dist/es/polyfill.js\");\n/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ponyfill.js */ \"(ssr)/./node_modules/barcode-detector/dist/es/ponyfill.js\");\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFyY29kZS1kZXRlY3Rvci9kaXN0L2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF1QjtBQUNvTDtBQVN6TSIsInNvdXJjZXMiOlsiRTpcXG5pZ2h0XFxjYW1wdXNwYXNzLWZsb3ctZGVtb1xcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcYmFyY29kZS1kZXRlY3RvclxcZGlzdFxcZXNcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBcIi4vcG9seWZpbGwuanNcIjtcbmltcG9ydCB7IEJhcmNvZGVEZXRlY3RvciBhcyBNLCBaWElOR19DUFBfQ09NTUlUIGFzIFgsIFpYSU5HX1dBU01fU0hBMjU2IGFzIFosIFpYSU5HX1dBU01fVkVSU0lPTiBhcyBfLCBwcmVwYXJlWlhpbmdNb2R1bGUgYXMgZCwgcHVyZ2VaWGluZ01vZHVsZSBhcyBpLCBzZXRaWGluZ01vZHVsZU92ZXJyaWRlcyBhcyBwIH0gZnJvbSBcIi4vcG9ueWZpbGwuanNcIjtcbmV4cG9ydCB7XG4gIE0gYXMgQmFyY29kZURldGVjdG9yLFxuICBYIGFzIFpYSU5HX0NQUF9DT01NSVQsXG4gIFogYXMgWlhJTkdfV0FTTV9TSEEyNTYsXG4gIF8gYXMgWlhJTkdfV0FTTV9WRVJTSU9OLFxuICBkIGFzIHByZXBhcmVaWGluZ01vZHVsZSxcbiAgaSBhcyBwdXJnZVpYaW5nTW9kdWxlLFxuICBwIGFzIHNldFpYaW5nTW9kdWxlT3ZlcnJpZGVzXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/barcode-detector/dist/es/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/barcode-detector/dist/es/polyfill.js":
/*!***********************************************************!*\
  !*** ./node_modules/barcode-detector/dist/es/polyfill.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZXING_CPP_COMMIT: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.ZXING_CPP_COMMIT),\n/* harmony export */   ZXING_WASM_SHA256: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.ZXING_WASM_SHA256),\n/* harmony export */   ZXING_WASM_VERSION: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.ZXING_WASM_VERSION),\n/* harmony export */   prepareZXingModule: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.prepareZXingModule),\n/* harmony export */   purgeZXingModule: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.purgeZXingModule),\n/* harmony export */   setZXingModuleOverrides: () => (/* reexport safe */ _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.setZXingModuleOverrides)\n/* harmony export */ });\n/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ponyfill.js */ \"(ssr)/./node_modules/barcode-detector/dist/es/ponyfill.js\");\n\n\nvar e;\n(e = globalThis.BarcodeDetector) != null || (globalThis.BarcodeDetector = _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__.BarcodeDetector);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFyY29kZS1kZXRlY3Rvci9kaXN0L2VzL3BvbHlmaWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBcUQ7QUFDZ0k7QUFDckw7QUFDQSwwRUFBMEUseURBQUM7QUFRekUiLCJzb3VyY2VzIjpbIkU6XFxuaWdodFxcY2FtcHVzcGFzcy1mbG93LWRlbW9cXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXGJhcmNvZGUtZGV0ZWN0b3JcXGRpc3RcXGVzXFxwb2x5ZmlsbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXJjb2RlRGV0ZWN0b3IgYXMgciB9IGZyb20gXCIuL3BvbnlmaWxsLmpzXCI7XG5pbXBvcnQgeyBaWElOR19DUFBfQ09NTUlUIGFzIGQsIFpYSU5HX1dBU01fU0hBMjU2IGFzIGksIFpYSU5HX1dBU01fVkVSU0lPTiBhcyBYLCBwcmVwYXJlWlhpbmdNb2R1bGUgYXMgWiwgcHVyZ2VaWGluZ01vZHVsZSBhcyBfLCBzZXRaWGluZ01vZHVsZU92ZXJyaWRlcyBhcyBnIH0gZnJvbSBcIi4vcG9ueWZpbGwuanNcIjtcbnZhciBlO1xuKGUgPSBnbG9iYWxUaGlzLkJhcmNvZGVEZXRlY3RvcikgIT0gbnVsbCB8fCAoZ2xvYmFsVGhpcy5CYXJjb2RlRGV0ZWN0b3IgPSByKTtcbmV4cG9ydCB7XG4gIGQgYXMgWlhJTkdfQ1BQX0NPTU1JVCxcbiAgaSBhcyBaWElOR19XQVNNX1NIQTI1NixcbiAgWCBhcyBaWElOR19XQVNNX1ZFUlNJT04sXG4gIFogYXMgcHJlcGFyZVpYaW5nTW9kdWxlLFxuICBfIGFzIHB1cmdlWlhpbmdNb2R1bGUsXG4gIGcgYXMgc2V0WlhpbmdNb2R1bGVPdmVycmlkZXNcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/barcode-detector/dist/es/polyfill.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/barcode-detector/dist/es/ponyfill.js":
/*!***********************************************************!*\
  !*** ./node_modules/barcode-detector/dist/es/ponyfill.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BarcodeDetector: () => (/* binding */ bo),\n/* harmony export */   ZXING_CPP_COMMIT: () => (/* binding */ vo),\n/* harmony export */   ZXING_WASM_SHA256: () => (/* binding */ wo),\n/* harmony export */   ZXING_WASM_VERSION: () => (/* binding */ yo),\n/* harmony export */   prepareZXingModule: () => (/* binding */ qe),\n/* harmony export */   purgeZXingModule: () => (/* binding */ mo),\n/* harmony export */   setZXingModuleOverrides: () => (/* binding */ go)\n/* harmony export */ });\nvar Ue = (o) => {\n  throw TypeError(o);\n};\nvar Ve = (o, l, d) => l.has(o) || Ue(\"Cannot \" + d);\nvar We = (o, l, d) => (Ve(o, l, \"read from private field\"), d ? d.call(o) : l.get(o)), He = (o, l, d) => l.has(o) ? Ue(\"Cannot add the same private member more than once\") : l instanceof WeakSet ? l.add(o) : l.set(o, d), ke = (o, l, d, b) => (Ve(o, l, \"write to private field\"), b ? b.call(o, d) : l.set(o, d), d);\nconst Dt = [\n  [\"Aztec\", \"M\"],\n  [\"Codabar\", \"L\"],\n  [\"Code39\", \"L\"],\n  [\"Code93\", \"L\"],\n  [\"Code128\", \"L\"],\n  [\"DataBar\", \"L\"],\n  [\"DataBarExpanded\", \"L\"],\n  [\"DataMatrix\", \"M\"],\n  [\"EAN-8\", \"L\"],\n  [\"EAN-13\", \"L\"],\n  [\"ITF\", \"L\"],\n  [\"MaxiCode\", \"M\"],\n  [\"PDF417\", \"M\"],\n  [\"QRCode\", \"M\"],\n  [\"UPC-A\", \"L\"],\n  [\"UPC-E\", \"L\"],\n  [\"MicroQRCode\", \"M\"],\n  [\"rMQRCode\", \"M\"],\n  [\"DXFilmEdge\", \"L\"],\n  [\"DataBarLimited\", \"L\"]\n], Mt = Dt.map(([o]) => o), Ma = Mt.filter(\n  (o, l) => Dt[l][1] === \"L\"\n), Aa = Mt.filter(\n  (o, l) => Dt[l][1] === \"M\"\n);\nfunction qt(o) {\n  switch (o) {\n    case \"Linear-Codes\":\n      return Ma.reduce((l, d) => l | qt(d), 0);\n    case \"Matrix-Codes\":\n      return Aa.reduce((l, d) => l | qt(d), 0);\n    case \"Any\":\n      return (1 << Dt.length) - 1;\n    case \"None\":\n      return 0;\n    default:\n      return 1 << Mt.indexOf(o);\n  }\n}\nfunction Fa(o) {\n  if (o === 0)\n    return \"None\";\n  const l = 31 - Math.clz32(o);\n  return Mt[l];\n}\nfunction Ra(o) {\n  return o.reduce((l, d) => l | qt(d), 0);\n}\nconst La = [\n  \"LocalAverage\",\n  \"GlobalHistogram\",\n  \"FixedThreshold\",\n  \"BoolCast\"\n];\nfunction ja(o) {\n  return La.indexOf(o);\n}\nconst Ne = [\n  \"Unknown\",\n  \"ASCII\",\n  \"ISO8859_1\",\n  \"ISO8859_2\",\n  \"ISO8859_3\",\n  \"ISO8859_4\",\n  \"ISO8859_5\",\n  \"ISO8859_6\",\n  \"ISO8859_7\",\n  \"ISO8859_8\",\n  \"ISO8859_9\",\n  \"ISO8859_10\",\n  \"ISO8859_11\",\n  \"ISO8859_13\",\n  \"ISO8859_14\",\n  \"ISO8859_15\",\n  \"ISO8859_16\",\n  \"Cp437\",\n  \"Cp1250\",\n  \"Cp1251\",\n  \"Cp1252\",\n  \"Cp1256\",\n  \"Shift_JIS\",\n  \"Big5\",\n  \"GB2312\",\n  \"GB18030\",\n  \"EUC_JP\",\n  \"EUC_KR\",\n  \"UTF16BE\",\n  /**\n   * UnicodeBig [[deprecated]]\n   */\n  \"UTF16BE\",\n  \"UTF8\",\n  \"UTF16LE\",\n  \"UTF32BE\",\n  \"UTF32LE\",\n  \"BINARY\"\n];\nfunction Ba(o) {\n  return o === \"UnicodeBig\" ? Ne.indexOf(\"UTF16BE\") : Ne.indexOf(o);\n}\nconst Ua = [\n  \"Text\",\n  \"Binary\",\n  \"Mixed\",\n  \"GS1\",\n  \"ISO15434\",\n  \"UnknownECI\"\n];\nfunction Va(o) {\n  return Ua[o];\n}\nconst Wa = [\"Ignore\", \"Read\", \"Require\"];\nfunction Ha(o) {\n  return Wa.indexOf(o);\n}\nconst ka = [\"Plain\", \"ECI\", \"HRI\", \"Hex\", \"Escaped\"];\nfunction Na(o) {\n  return ka.indexOf(o);\n}\nconst It = {\n  formats: [],\n  tryHarder: !0,\n  tryRotate: !0,\n  tryInvert: !0,\n  tryDownscale: !0,\n  tryDenoise: !1,\n  binarizer: \"LocalAverage\",\n  isPure: !1,\n  downscaleFactor: 3,\n  downscaleThreshold: 500,\n  minLineCount: 2,\n  maxNumberOfSymbols: 255,\n  tryCode39ExtendedMode: !0,\n  returnErrors: !1,\n  eanAddOnSymbol: \"Ignore\",\n  textMode: \"HRI\",\n  characterSet: \"Unknown\"\n};\nfunction ze(o) {\n  return {\n    ...o,\n    formats: Ra(o.formats),\n    binarizer: ja(o.binarizer),\n    eanAddOnSymbol: Ha(o.eanAddOnSymbol),\n    textMode: Na(o.textMode),\n    characterSet: Ba(o.characterSet)\n  };\n}\nfunction za(o) {\n  return {\n    ...o,\n    format: Fa(o.format),\n    contentType: Va(o.contentType),\n    eccLevel: o.ecLevel\n  };\n}\nconst yo = \"2.2.4\", vo = \"fba4e9503fee4518ca2e89510baeea9bcc36dc8d\", Ga = {\n  locateFile: (o, l) => {\n    const d = o.match(/_(.+?)\\.wasm$/);\n    return d ? `https://fastly.jsdelivr.net/npm/zxing-wasm@2.2.4/dist/${d[1]}/${o}` : l + o;\n  }\n}, St = /* @__PURE__ */ new WeakMap();\nfunction Xa(o, l) {\n  return Object.is(o, l) || Object.keys(o).length === Object.keys(l).length && Object.keys(o).every(\n    (d) => Object.hasOwn(l, d) && o[d] === l[d]\n  );\n}\nfunction Xe(o, {\n  overrides: l,\n  equalityFn: d = Xa,\n  fireImmediately: b = !1\n} = {}) {\n  var f;\n  const [I, D] = (f = St.get(o)) != null ? f : [Ga], M = l != null ? l : I;\n  let _;\n  if (b) {\n    if (D && (_ = d(I, M)))\n      return D;\n    const A = o({\n      ...M\n    });\n    return St.set(o, [M, A]), A;\n  }\n  (_ != null ? _ : d(I, M)) || St.set(o, [M]);\n}\nfunction qa(o) {\n  St.delete(o);\n}\nasync function Ya(o, l, d = It) {\n  const b = {\n    ...It,\n    ...d\n  }, f = await Xe(o, {\n    fireImmediately: !0\n  });\n  let I, D;\n  if (\"width\" in l && \"height\" in l && \"data\" in l) {\n    const {\n      data: _,\n      data: { byteLength: A },\n      width: U,\n      height: G\n    } = l;\n    D = f._malloc(A), f.HEAPU8.set(_, D), I = f.readBarcodesFromPixmap(\n      D,\n      U,\n      G,\n      ze(b)\n    );\n  } else {\n    let _, A;\n    if (\"buffer\" in l)\n      [_, A] = [l.byteLength, l];\n    else if (\"byteLength\" in l)\n      [_, A] = [l.byteLength, new Uint8Array(l)];\n    else if (\"size\" in l)\n      [_, A] = [l.size, new Uint8Array(await l.arrayBuffer())];\n    else\n      throw new TypeError(\"Invalid input type\");\n    D = f._malloc(_), f.HEAPU8.set(A, D), I = f.readBarcodesFromImage(\n      D,\n      _,\n      ze(b)\n    );\n  }\n  f._free(D);\n  const M = [];\n  for (let _ = 0; _ < I.size(); ++_)\n    M.push(\n      za(I.get(_))\n    );\n  return M;\n}\n({\n  ...It,\n  formats: [...It.formats]\n});\nasync function Zt(o = {}) {\n  var l, d, b, f = o, I = !!globalThis.window, D = typeof Bun < \"u\", M = !!globalThis.WorkerGlobalScope;\n  !((d = globalThis.process) === null || d === void 0 || (d = d.versions) === null || d === void 0) && d.node && ((b = globalThis.process) === null || b === void 0 ? void 0 : b.type) != \"renderer\";\n  var _ = \"./this.program\", A, U = \"\";\n  function G(t) {\n    return f.locateFile ? f.locateFile(t, U) : U + t;\n  }\n  var tt, X;\n  if (I || M || D) {\n    try {\n      U = new URL(\".\", A).href;\n    } catch {\n    }\n    M && (X = (t) => {\n      var e = new XMLHttpRequest();\n      return e.open(\"GET\", t, !1), e.responseType = \"arraybuffer\", e.send(null), new Uint8Array(e.response);\n    }), tt = async (t) => {\n      var e = await fetch(t, {\n        credentials: \"same-origin\"\n      });\n      if (e.ok)\n        return e.arrayBuffer();\n      throw new Error(e.status + \" : \" + e.url);\n    };\n  }\n  var nt = console.log.bind(console), V = console.error.bind(console), q, ht = !1, Qt, Jt, Y, W, dt, at, ot, T, Kt, te, ee = !1;\n  function re() {\n    var t = Pt.buffer;\n    Y = new Int8Array(t), dt = new Int16Array(t), f.HEAPU8 = W = new Uint8Array(t), at = new Uint16Array(t), ot = new Int32Array(t), T = new Uint32Array(t), Kt = new Float32Array(t), te = new Float64Array(t);\n  }\n  function ar() {\n    if (f.preRun)\n      for (typeof f.preRun == \"function\" && (f.preRun = [f.preRun]); f.preRun.length; )\n        yr(f.preRun.shift());\n    ne(oe);\n  }\n  function or() {\n    ee = !0, lt.xa();\n  }\n  function ir() {\n    if (f.postRun)\n      for (typeof f.postRun == \"function\" && (f.postRun = [f.postRun]); f.postRun.length; )\n        pr(f.postRun.shift());\n    ne(ae);\n  }\n  function At(t) {\n    var e, r;\n    (e = f.onAbort) === null || e === void 0 || e.call(f, t), t = \"Aborted(\" + t + \")\", V(t), ht = !0, t += \". Build with -sASSERTIONS for more info.\";\n    var n = new WebAssembly.RuntimeError(t);\n    throw (r = Jt) === null || r === void 0 || r(n), n;\n  }\n  var pt;\n  function sr() {\n    return G(\"zxing_reader.wasm\");\n  }\n  function ur(t) {\n    if (t == pt && q)\n      return new Uint8Array(q);\n    if (X)\n      return X(t);\n    throw \"both async and sync fetching of the wasm failed\";\n  }\n  async function cr(t) {\n    if (!q)\n      try {\n        var e = await tt(t);\n        return new Uint8Array(e);\n      } catch {\n      }\n    return ur(t);\n  }\n  async function lr(t, e) {\n    try {\n      var r = await cr(t), n = await WebAssembly.instantiate(r, e);\n      return n;\n    } catch (a) {\n      V(`failed to asynchronously prepare wasm: ${a}`), At(a);\n    }\n  }\n  async function fr(t, e, r) {\n    if (!t && WebAssembly.instantiateStreaming)\n      try {\n        var n = fetch(e, {\n          credentials: \"same-origin\"\n        }), a = await WebAssembly.instantiateStreaming(n, r);\n        return a;\n      } catch (i) {\n        V(`wasm streaming compile failed: ${i}`), V(\"falling back to ArrayBuffer instantiation\");\n      }\n    return lr(e, r);\n  }\n  function hr() {\n    var t = {\n      a: qn\n    };\n    return t;\n  }\n  async function dr() {\n    function t(i, s) {\n      return lt = i.exports, Xn(lt), re(), lt;\n    }\n    function e(i) {\n      return t(i.instance);\n    }\n    var r = hr();\n    if (f.instantiateWasm)\n      return new Promise((i, s) => {\n        f.instantiateWasm(r, (u, c) => {\n          i(t(u));\n        });\n      });\n    pt != null || (pt = sr());\n    var n = await fr(q, pt, r), a = e(n);\n    return a;\n  }\n  var ne = (t) => {\n    for (; t.length > 0; )\n      t.shift()(f);\n  }, ae = [], pr = (t) => ae.push(t), oe = [], yr = (t) => oe.push(t), m = (t) => _e(t), g = () => xe(), yt = [], vt = 0, vr = (t) => {\n    var e = new Ft(t);\n    return e.get_caught() || (e.set_caught(!0), vt--), e.set_rethrown(!1), yt.push(e), Ie(t), Pe(t);\n  }, H = 0, mr = () => {\n    v(0, 0);\n    var t = yt.pop();\n    Se(t.excPtr), H = 0;\n  };\n  class Ft {\n    constructor(e) {\n      this.excPtr = e, this.ptr = e - 24;\n    }\n    set_type(e) {\n      T[this.ptr + 4 >> 2] = e;\n    }\n    get_type() {\n      return T[this.ptr + 4 >> 2];\n    }\n    set_destructor(e) {\n      T[this.ptr + 8 >> 2] = e;\n    }\n    get_destructor() {\n      return T[this.ptr + 8 >> 2];\n    }\n    set_caught(e) {\n      e = e ? 1 : 0, Y[this.ptr + 12] = e;\n    }\n    get_caught() {\n      return Y[this.ptr + 12] != 0;\n    }\n    set_rethrown(e) {\n      e = e ? 1 : 0, Y[this.ptr + 13] = e;\n    }\n    get_rethrown() {\n      return Y[this.ptr + 13] != 0;\n    }\n    init(e, r) {\n      this.set_adjusted_ptr(0), this.set_type(e), this.set_destructor(r);\n    }\n    set_adjusted_ptr(e) {\n      T[this.ptr + 16 >> 2] = e;\n    }\n    get_adjusted_ptr() {\n      return T[this.ptr + 16 >> 2];\n    }\n  }\n  var mt = (t) => Oe(t), Rt = (t) => {\n    var e = H;\n    if (!e)\n      return mt(0), 0;\n    var r = new Ft(e);\n    r.set_adjusted_ptr(e);\n    var n = r.get_type();\n    if (!n)\n      return mt(0), e;\n    for (var a of t) {\n      if (a === 0 || a === n)\n        break;\n      var i = r.ptr + 16;\n      if (De(a, n, i))\n        return mt(a), e;\n    }\n    return mt(n), e;\n  }, gr = () => Rt([]), wr = (t) => Rt([t]), br = (t, e) => Rt([t, e]), $r = () => {\n    var t = yt.pop();\n    t || At(\"no exception to throw\");\n    var e = t.excPtr;\n    throw t.get_rethrown() || (yt.push(t), t.set_rethrown(!0), t.set_caught(!1), vt++), H = e, H;\n  }, Cr = (t, e, r) => {\n    var n = new Ft(t);\n    throw n.init(e, r), H = t, vt++, H;\n  }, Tr = () => vt, Er = (t) => {\n    throw H || (H = t), H;\n  }, Pr = () => At(\"\"), gt = {}, Lt = (t) => {\n    for (; t.length; ) {\n      var e = t.pop(), r = t.pop();\n      r(e);\n    }\n  };\n  function it(t) {\n    return this.fromWireType(T[t >> 2]);\n  }\n  var et = {}, Z = {}, wt = {}, Or = class extends Error {\n    constructor(t) {\n      super(t), this.name = \"InternalError\";\n    }\n  }, bt = (t) => {\n    throw new Or(t);\n  }, Q = (t, e, r) => {\n    t.forEach((u) => wt[u] = e);\n    function n(u) {\n      var c = r(u);\n      c.length !== t.length && bt(\"Mismatched type converter count\");\n      for (var h = 0; h < t.length; ++h)\n        j(t[h], c[h]);\n    }\n    var a = new Array(e.length), i = [], s = 0;\n    {\n      const u = e;\n      for (let c = 0; c < u.length; ++c) {\n        const h = u[c];\n        Z.hasOwnProperty(h) ? a[c] = Z[h] : (i.push(h), et.hasOwnProperty(h) || (et[h] = []), et[h].push(() => {\n          a[c] = Z[h], ++s, s === i.length && n(a);\n        }));\n      }\n    }\n    i.length === 0 && n(a);\n  }, _r = (t) => {\n    var e = gt[t];\n    delete gt[t];\n    var r = e.rawConstructor, n = e.rawDestructor, a = e.fields, i = a.map((s) => s.getterReturnType).concat(a.map((s) => s.setterArgumentType));\n    Q([t], i, (s) => {\n      var u = {};\n      {\n        const c = a;\n        for (let h = 0; h < c.length; ++h) {\n          const p = c[h], y = s[h], C = p.getter, P = p.getterContext, S = s[h + a.length], x = p.setter, O = p.setterContext;\n          u[p.fieldName] = {\n            read: (E) => y.fromWireType(C(P, E)),\n            write: (E, K) => {\n              var R = [];\n              x(O, E, S.toWireType(R, K)), Lt(R);\n            },\n            optional: y.optional\n          };\n        }\n      }\n      return [{\n        name: e.name,\n        fromWireType: (c) => {\n          var h = {};\n          for (var p in u)\n            h[p] = u[p].read(c);\n          return n(c), h;\n        },\n        toWireType: (c, h) => {\n          for (var p in u)\n            if (!(p in h) && !u[p].optional)\n              throw new TypeError(`Missing field: \"${p}\"`);\n          var y = r();\n          for (p in u)\n            u[p].write(y, h[p]);\n          return c !== null && c.push(n, y), y;\n        },\n        readValueFromPointer: it,\n        destructorFunction: n\n      }];\n    });\n  }, xr = (t, e, r, n, a) => {\n  }, F = (t) => {\n    for (var e = \"\"; ; ) {\n      var r = W[t++];\n      if (!r) return e;\n      e += String.fromCharCode(r);\n    }\n  }, st = class extends Error {\n    constructor(t) {\n      super(t), this.name = \"BindingError\";\n    }\n  }, $ = (t) => {\n    throw new st(t);\n  };\n  function Sr(t, e) {\n    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var n = e.name;\n    if (t || $(`type \"${n}\" must have a positive integer typeid pointer`), Z.hasOwnProperty(t)) {\n      if (r.ignoreDuplicateRegistrations)\n        return;\n      $(`Cannot register type '${n}' twice`);\n    }\n    if (Z[t] = e, delete wt[t], et.hasOwnProperty(t)) {\n      var a = et[t];\n      delete et[t], a.forEach((i) => i());\n    }\n  }\n  function j(t, e) {\n    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return Sr(t, e, r);\n  }\n  var Ir = (t, e, r, n) => {\n    e = F(e), j(t, {\n      name: e,\n      fromWireType: function(a) {\n        return !!a;\n      },\n      toWireType: function(a, i) {\n        return i ? r : n;\n      },\n      readValueFromPointer: function(a) {\n        return this.fromWireType(W[a]);\n      },\n      destructorFunction: null\n    });\n  }, Dr = (t) => ({\n    count: t.count,\n    deleteScheduled: t.deleteScheduled,\n    preservePointerOnDelete: t.preservePointerOnDelete,\n    ptr: t.ptr,\n    ptrType: t.ptrType,\n    smartPtr: t.smartPtr,\n    smartPtrType: t.smartPtrType\n  }), jt = (t) => {\n    function e(r) {\n      return r.$$.ptrType.registeredClass.name;\n    }\n    $(e(t) + \" instance already deleted\");\n  }, Bt = !1, ie = (t) => {\n  }, Mr = (t) => {\n    t.smartPtr ? t.smartPtrType.rawDestructor(t.smartPtr) : t.ptrType.registeredClass.rawDestructor(t.ptr);\n  }, se = (t) => {\n    t.count.value -= 1;\n    var e = t.count.value === 0;\n    e && Mr(t);\n  }, ut = (t) => globalThis.FinalizationRegistry ? (Bt = new FinalizationRegistry((e) => {\n    se(e.$$);\n  }), ut = (e) => {\n    var r = e.$$, n = !!r.smartPtr;\n    if (n) {\n      var a = {\n        $$: r\n      };\n      Bt.register(e, a, e);\n    }\n    return e;\n  }, ie = (e) => Bt.unregister(e), ut(t)) : (ut = (e) => e, t), Ar = () => {\n    let t = $t.prototype;\n    Object.assign(t, {\n      isAliasOf(r) {\n        if (!(this instanceof $t) || !(r instanceof $t))\n          return !1;\n        var n = this.$$.ptrType.registeredClass, a = this.$$.ptr;\n        r.$$ = r.$$;\n        for (var i = r.$$.ptrType.registeredClass, s = r.$$.ptr; n.baseClass; )\n          a = n.upcast(a), n = n.baseClass;\n        for (; i.baseClass; )\n          s = i.upcast(s), i = i.baseClass;\n        return n === i && a === s;\n      },\n      clone() {\n        if (this.$$.ptr || jt(this), this.$$.preservePointerOnDelete)\n          return this.$$.count.value += 1, this;\n        var r = ut(Object.create(Object.getPrototypeOf(this), {\n          $$: {\n            value: Dr(this.$$)\n          }\n        }));\n        return r.$$.count.value += 1, r.$$.deleteScheduled = !1, r;\n      },\n      delete() {\n        this.$$.ptr || jt(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && $(\"Object already scheduled for deletion\"), ie(this), se(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0);\n      },\n      isDeleted() {\n        return !this.$$.ptr;\n      },\n      deleteLater() {\n        return this.$$.ptr || jt(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && $(\"Object already scheduled for deletion\"), this.$$.deleteScheduled = !0, this;\n      }\n    });\n    const e = Symbol.dispose;\n    e && (t[e] = t.delete);\n  };\n  function $t() {\n  }\n  var Ut = (t, e) => Object.defineProperty(e, \"name\", {\n    value: t\n  }), ue = {}, ce = (t, e, r) => {\n    if (t[e].overloadTable === void 0) {\n      var n = t[e];\n      t[e] = function() {\n        for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++)\n          i[s] = arguments[s];\n        return t[e].overloadTable.hasOwnProperty(i.length) || $(`Function '${r}' called with an invalid number of arguments (${i.length}) - expects one of (${t[e].overloadTable})!`), t[e].overloadTable[i.length].apply(this, i);\n      }, t[e].overloadTable = [], t[e].overloadTable[n.argCount] = n;\n    }\n  }, le = (t, e, r) => {\n    f.hasOwnProperty(t) ? ((r === void 0 || f[t].overloadTable !== void 0 && f[t].overloadTable[r] !== void 0) && $(`Cannot register public name '${t}' twice`), ce(f, t, t), f[t].overloadTable.hasOwnProperty(r) && $(`Cannot register multiple overloads of a function with the same number of arguments (${r})!`), f[t].overloadTable[r] = e) : (f[t] = e, f[t].argCount = r);\n  }, Fr = 48, Rr = 57, Lr = (t) => {\n    t = t.replace(/[^a-zA-Z0-9_]/g, \"$\");\n    var e = t.charCodeAt(0);\n    return e >= Fr && e <= Rr ? `_${t}` : t;\n  };\n  function jr(t, e, r, n, a, i, s, u) {\n    this.name = t, this.constructor = e, this.instancePrototype = r, this.rawDestructor = n, this.baseClass = a, this.getActualType = i, this.upcast = s, this.downcast = u, this.pureVirtualFunctions = [];\n  }\n  var Vt = (t, e, r) => {\n    for (; e !== r; )\n      e.upcast || $(`Expected null or instance of ${r.name}, got an instance of ${e.name}`), t = e.upcast(t), e = e.baseClass;\n    return t;\n  }, Wt = (t) => {\n    if (t === null)\n      return \"null\";\n    var e = typeof t;\n    return e === \"object\" || e === \"array\" || e === \"function\" ? t.toString() : \"\" + t;\n  };\n  function Br(t, e) {\n    if (e === null)\n      return this.isReference && $(`null is not a valid ${this.name}`), 0;\n    e.$$ || $(`Cannot pass \"${Wt(e)}\" as a ${this.name}`), e.$$.ptr || $(`Cannot pass deleted object as a pointer of type ${this.name}`);\n    var r = e.$$.ptrType.registeredClass, n = Vt(e.$$.ptr, r, this.registeredClass);\n    return n;\n  }\n  function Ur(t, e) {\n    var r;\n    if (e === null)\n      return this.isReference && $(`null is not a valid ${this.name}`), this.isSmartPointer ? (r = this.rawConstructor(), t !== null && t.push(this.rawDestructor, r), r) : 0;\n    (!e || !e.$$) && $(`Cannot pass \"${Wt(e)}\" as a ${this.name}`), e.$$.ptr || $(`Cannot pass deleted object as a pointer of type ${this.name}`), !this.isConst && e.$$.ptrType.isConst && $(`Cannot convert argument of type ${e.$$.smartPtrType ? e.$$.smartPtrType.name : e.$$.ptrType.name} to parameter type ${this.name}`);\n    var n = e.$$.ptrType.registeredClass;\n    if (r = Vt(e.$$.ptr, n, this.registeredClass), this.isSmartPointer)\n      switch (e.$$.smartPtr === void 0 && $(\"Passing raw pointer to smart pointer is illegal\"), this.sharingPolicy) {\n        case 0:\n          e.$$.smartPtrType === this ? r = e.$$.smartPtr : $(`Cannot convert argument of type ${e.$$.smartPtrType ? e.$$.smartPtrType.name : e.$$.ptrType.name} to parameter type ${this.name}`);\n          break;\n        case 1:\n          r = e.$$.smartPtr;\n          break;\n        case 2:\n          if (e.$$.smartPtrType === this)\n            r = e.$$.smartPtr;\n          else {\n            var a = e.clone();\n            r = this.rawShare(r, B.toHandle(() => a.delete())), t !== null && t.push(this.rawDestructor, r);\n          }\n          break;\n        default:\n          $(\"Unsupporting sharing policy\");\n      }\n    return r;\n  }\n  function Vr(t, e) {\n    if (e === null)\n      return this.isReference && $(`null is not a valid ${this.name}`), 0;\n    e.$$ || $(`Cannot pass \"${Wt(e)}\" as a ${this.name}`), e.$$.ptr || $(`Cannot pass deleted object as a pointer of type ${this.name}`), e.$$.ptrType.isConst && $(`Cannot convert argument of type ${e.$$.ptrType.name} to parameter type ${this.name}`);\n    var r = e.$$.ptrType.registeredClass, n = Vt(e.$$.ptr, r, this.registeredClass);\n    return n;\n  }\n  var fe = (t, e, r) => {\n    if (e === r)\n      return t;\n    if (r.baseClass === void 0)\n      return null;\n    var n = fe(t, e, r.baseClass);\n    return n === null ? null : r.downcast(n);\n  }, Wr = {}, Hr = (t, e) => {\n    for (e === void 0 && $(\"ptr should not be undefined\"); t.baseClass; )\n      e = t.upcast(e), t = t.baseClass;\n    return e;\n  }, kr = (t, e) => (e = Hr(t, e), Wr[e]), Ct = (t, e) => {\n    (!e.ptrType || !e.ptr) && bt(\"makeClassHandle requires ptr and ptrType\");\n    var r = !!e.smartPtrType, n = !!e.smartPtr;\n    return r !== n && bt(\"Both smartPtrType and smartPtr must be specified\"), e.count = {\n      value: 1\n    }, ut(Object.create(t, {\n      $$: {\n        value: e,\n        writable: !0\n      }\n    }));\n  };\n  function Nr(t) {\n    var e = this.getPointee(t);\n    if (!e)\n      return this.destructor(t), null;\n    var r = kr(this.registeredClass, e);\n    if (r !== void 0) {\n      if (r.$$.count.value === 0)\n        return r.$$.ptr = e, r.$$.smartPtr = t, r.clone();\n      var n = r.clone();\n      return this.destructor(t), n;\n    }\n    function a() {\n      return this.isSmartPointer ? Ct(this.registeredClass.instancePrototype, {\n        ptrType: this.pointeeType,\n        ptr: e,\n        smartPtrType: this,\n        smartPtr: t\n      }) : Ct(this.registeredClass.instancePrototype, {\n        ptrType: this,\n        ptr: t\n      });\n    }\n    var i = this.registeredClass.getActualType(e), s = ue[i];\n    if (!s)\n      return a.call(this);\n    var u;\n    this.isConst ? u = s.constPointerType : u = s.pointerType;\n    var c = fe(e, this.registeredClass, u.registeredClass);\n    return c === null ? a.call(this) : this.isSmartPointer ? Ct(u.registeredClass.instancePrototype, {\n      ptrType: u,\n      ptr: c,\n      smartPtrType: this,\n      smartPtr: t\n    }) : Ct(u.registeredClass.instancePrototype, {\n      ptrType: u,\n      ptr: c\n    });\n  }\n  var zr = () => {\n    Object.assign(Tt.prototype, {\n      getPointee(t) {\n        return this.rawGetPointee && (t = this.rawGetPointee(t)), t;\n      },\n      destructor(t) {\n        var e;\n        (e = this.rawDestructor) === null || e === void 0 || e.call(this, t);\n      },\n      readValueFromPointer: it,\n      fromWireType: Nr\n    });\n  };\n  function Tt(t, e, r, n, a, i, s, u, c, h, p) {\n    this.name = t, this.registeredClass = e, this.isReference = r, this.isConst = n, this.isSmartPointer = a, this.pointeeType = i, this.sharingPolicy = s, this.rawGetPointee = u, this.rawConstructor = c, this.rawShare = h, this.rawDestructor = p, !a && e.baseClass === void 0 ? n ? (this.toWireType = Br, this.destructorFunction = null) : (this.toWireType = Vr, this.destructorFunction = null) : this.toWireType = Ur;\n  }\n  var he = (t, e, r) => {\n    f.hasOwnProperty(t) || bt(\"Replacing nonexistent public symbol\"), f[t].overloadTable !== void 0 && r !== void 0 ? f[t].overloadTable[r] = e : (f[t] = e, f[t].argCount = r);\n  }, N = {}, Gr = (t, e, r) => {\n    t = t.replace(/p/g, \"i\");\n    var n = N[t];\n    return n(e, ...r);\n  }, de = [], w = (t) => {\n    var e = de[t];\n    return e || (de[t] = e = Fe.get(t)), e;\n  }, Xr = function(t, e) {\n    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n    if (t.includes(\"j\"))\n      return Gr(t, e, r);\n    var n = w(e), a = n(...r);\n    return a;\n  }, qr = function(t, e) {\n    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n    return function() {\n      for (var n = arguments.length, a = new Array(n), i = 0; i < n; i++)\n        a[i] = arguments[i];\n      return Xr(t, e, a, r);\n    };\n  }, L = function(t, e) {\n    t = F(t);\n    function r() {\n      if (t.includes(\"j\"))\n        return qr(t, e);\n      var a = w(e);\n      return a;\n    }\n    var n = r();\n    return typeof n != \"function\" && $(`unknown function pointer with signature ${t}: ${e}`), n;\n  };\n  class Yr extends Error {\n  }\n  var pe = (t) => {\n    var e = Ee(t), r = F(e);\n    return z(e), r;\n  }, Et = (t, e) => {\n    var r = [], n = {};\n    function a(i) {\n      if (!n[i] && !Z[i]) {\n        if (wt[i]) {\n          wt[i].forEach(a);\n          return;\n        }\n        r.push(i), n[i] = !0;\n      }\n    }\n    throw e.forEach(a), new Yr(`${t}: ` + r.map(pe).join([\", \"]));\n  }, Zr = (t, e, r, n, a, i, s, u, c, h, p, y, C) => {\n    p = F(p), i = L(a, i), u && (u = L(s, u)), h && (h = L(c, h)), C = L(y, C);\n    var P = Lr(p);\n    le(P, function() {\n      Et(`Cannot construct ${p} due to unbound types`, [n]);\n    }), Q([t, e, r], n ? [n] : [], (S) => {\n      S = S[0];\n      var x, O;\n      n ? (x = S.registeredClass, O = x.instancePrototype) : O = $t.prototype;\n      var E = Ut(p, function() {\n        if (Object.getPrototypeOf(this) !== K)\n          throw new st(`Use 'new' to construct ${p}`);\n        if (R.constructor_body === void 0)\n          throw new st(`${p} has no accessible constructor`);\n        for (var je = arguments.length, _t = new Array(je), xt = 0; xt < je; xt++)\n          _t[xt] = arguments[xt];\n        var Be = R.constructor_body[_t.length];\n        if (Be === void 0)\n          throw new st(`Tried to invoke ctor of ${p} with invalid number of parameters (${_t.length}) - expected (${Object.keys(R.constructor_body).toString()}) parameters instead!`);\n        return Be.apply(this, _t);\n      }), K = Object.create(O, {\n        constructor: {\n          value: E\n        }\n      });\n      E.prototype = K;\n      var R = new jr(p, E, K, C, x, i, u, h);\n      if (R.baseClass) {\n        var k, Ot;\n        (Ot = (k = R.baseClass).__derivedClasses) !== null && Ot !== void 0 || (k.__derivedClasses = []), R.baseClass.__derivedClasses.push(R);\n      }\n      var Da = new Tt(p, R, !0, !1, !1), Re = new Tt(p + \"*\", R, !1, !1, !1), Le = new Tt(p + \" const*\", R, !1, !0, !1);\n      return ue[t] = {\n        pointerType: Re,\n        constPointerType: Le\n      }, he(P, E), [Da, Re, Le];\n    });\n  }, Ht = (t, e) => {\n    for (var r = [], n = 0; n < t; n++)\n      r.push(T[e + n * 4 >> 2]);\n    return r;\n  };\n  function Qr(t) {\n    for (var e = 1; e < t.length; ++e)\n      if (t[e] !== null && t[e].destructorFunction === void 0)\n        return !0;\n    return !1;\n  }\n  function kt(t, e, r, n, a, i) {\n    var s = e.length;\n    s < 2 && $(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n    var u = e[1] !== null && r !== null, c = Qr(e), h = !e[0].isVoid, p = s - 2, y = new Array(p), C = [], P = [], S = function() {\n      P.length = 0;\n      var x;\n      C.length = u ? 2 : 1, C[0] = a, u && (x = e[1].toWireType(P, this), C[1] = x);\n      for (var O = 0; O < p; ++O)\n        y[O] = e[O + 2].toWireType(P, O < 0 || arguments.length <= O ? void 0 : arguments[O]), C.push(y[O]);\n      var E = n(...C);\n      function K(R) {\n        if (c)\n          Lt(P);\n        else\n          for (var k = u ? 1 : 2; k < e.length; k++) {\n            var Ot = k === 1 ? x : y[k - 2];\n            e[k].destructorFunction !== null && e[k].destructorFunction(Ot);\n          }\n        if (h)\n          return e[0].fromWireType(R);\n      }\n      return K(E);\n    };\n    return Ut(t, S);\n  }\n  var Jr = (t, e, r, n, a, i) => {\n    var s = Ht(e, r);\n    a = L(n, a), Q([], [t], (u) => {\n      u = u[0];\n      var c = `constructor ${u.name}`;\n      if (u.registeredClass.constructor_body === void 0 && (u.registeredClass.constructor_body = []), u.registeredClass.constructor_body[e - 1] !== void 0)\n        throw new st(`Cannot register multiple constructors with identical number of parameters (${e - 1}) for class '${u.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);\n      return u.registeredClass.constructor_body[e - 1] = () => {\n        Et(`Cannot construct ${u.name} due to unbound types`, s);\n      }, Q([], s, (h) => (h.splice(1, 0, null), u.registeredClass.constructor_body[e - 1] = kt(c, h, null, a, i), [])), [];\n    });\n  }, ye = (t) => {\n    t = t.trim();\n    const e = t.indexOf(\"(\");\n    return e === -1 ? t : t.slice(0, e);\n  }, Kr = (t, e, r, n, a, i, s, u, c, h) => {\n    var p = Ht(r, n);\n    e = F(e), e = ye(e), i = L(a, i), Q([], [t], (y) => {\n      y = y[0];\n      var C = `${y.name}.${e}`;\n      e.startsWith(\"@@\") && (e = Symbol[e.substring(2)]), u && y.registeredClass.pureVirtualFunctions.push(e);\n      function P() {\n        Et(`Cannot call ${C} due to unbound types`, p);\n      }\n      var S = y.registeredClass.instancePrototype, x = S[e];\n      return x === void 0 || x.overloadTable === void 0 && x.className !== y.name && x.argCount === r - 2 ? (P.argCount = r - 2, P.className = y.name, S[e] = P) : (ce(S, e, C), S[e].overloadTable[r - 2] = P), Q([], p, (O) => {\n        var E = kt(C, O, y, i, s);\n        return S[e].overloadTable === void 0 ? (E.argCount = r - 2, S[e] = E) : S[e].overloadTable[r - 2] = E, [];\n      }), [];\n    });\n  }, ve = [], J = [0, 1, , 1, null, 1, !0, 1, !1, 1], Nt = (t) => {\n    t > 9 && --J[t + 1] === 0 && (J[t] = void 0, ve.push(t));\n  }, B = {\n    toValue: (t) => (t || $(`Cannot use deleted val. handle = ${t}`), J[t]),\n    toHandle: (t) => {\n      switch (t) {\n        case void 0:\n          return 2;\n        case null:\n          return 4;\n        case !0:\n          return 6;\n        case !1:\n          return 8;\n        default: {\n          const e = ve.pop() || J.length;\n          return J[e] = t, J[e + 1] = 1, e;\n        }\n      }\n    }\n  }, me = {\n    name: \"emscripten::val\",\n    fromWireType: (t) => {\n      var e = B.toValue(t);\n      return Nt(t), e;\n    },\n    toWireType: (t, e) => B.toHandle(e),\n    readValueFromPointer: it,\n    destructorFunction: null\n  }, tn = (t) => j(t, me), en = (t, e) => {\n    switch (e) {\n      case 4:\n        return function(r) {\n          return this.fromWireType(Kt[r >> 2]);\n        };\n      case 8:\n        return function(r) {\n          return this.fromWireType(te[r >> 3]);\n        };\n      default:\n        throw new TypeError(`invalid float width (${e}): ${t}`);\n    }\n  }, rn = (t, e, r) => {\n    e = F(e), j(t, {\n      name: e,\n      fromWireType: (n) => n,\n      toWireType: (n, a) => a,\n      readValueFromPointer: en(e, r),\n      destructorFunction: null\n    });\n  }, nn = (t, e, r, n, a, i, s, u) => {\n    var c = Ht(e, r);\n    t = F(t), t = ye(t), a = L(n, a), le(t, function() {\n      Et(`Cannot call ${t} due to unbound types`, c);\n    }, e - 1), Q([], c, (h) => {\n      var p = [h[0], null].concat(h.slice(1));\n      return he(t, kt(t, p, null, a, i), e - 1), [];\n    });\n  }, an = (t, e, r) => {\n    switch (e) {\n      case 1:\n        return r ? (n) => Y[n] : (n) => W[n];\n      case 2:\n        return r ? (n) => dt[n >> 1] : (n) => at[n >> 1];\n      case 4:\n        return r ? (n) => ot[n >> 2] : (n) => T[n >> 2];\n      default:\n        throw new TypeError(`invalid integer width (${e}): ${t}`);\n    }\n  }, on = (t, e, r, n, a) => {\n    e = F(e);\n    const i = n === 0;\n    let s = (c) => c;\n    if (i) {\n      var u = 32 - 8 * r;\n      s = (c) => c << u >>> u, a = s(a);\n    }\n    j(t, {\n      name: e,\n      fromWireType: s,\n      toWireType: (c, h) => h,\n      readValueFromPointer: an(e, r, n !== 0),\n      destructorFunction: null\n    });\n  }, sn = (t, e, r) => {\n    var n = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], a = n[e];\n    function i(s) {\n      var u = T[s >> 2], c = T[s + 4 >> 2];\n      return new a(Y.buffer, c, u);\n    }\n    r = F(r), j(t, {\n      name: r,\n      fromWireType: i,\n      readValueFromPointer: i\n    }, {\n      ignoreDuplicateRegistrations: !0\n    });\n  }, un = Object.assign({\n    optional: !0\n  }, me), cn = (t, e) => {\n    j(t, un);\n  }, ln = (t, e, r, n) => {\n    if (!(n > 0)) return 0;\n    for (var a = r, i = r + n - 1, s = 0; s < t.length; ++s) {\n      var u = t.codePointAt(s);\n      if (u <= 127) {\n        if (r >= i) break;\n        e[r++] = u;\n      } else if (u <= 2047) {\n        if (r + 1 >= i) break;\n        e[r++] = 192 | u >> 6, e[r++] = 128 | u & 63;\n      } else if (u <= 65535) {\n        if (r + 2 >= i) break;\n        e[r++] = 224 | u >> 12, e[r++] = 128 | u >> 6 & 63, e[r++] = 128 | u & 63;\n      } else {\n        if (r + 3 >= i) break;\n        e[r++] = 240 | u >> 18, e[r++] = 128 | u >> 12 & 63, e[r++] = 128 | u >> 6 & 63, e[r++] = 128 | u & 63, s++;\n      }\n    }\n    return e[r] = 0, r - a;\n  }, rt = (t, e, r) => ln(t, W, e, r), ge = (t) => {\n    for (var e = 0, r = 0; r < t.length; ++r) {\n      var n = t.charCodeAt(r);\n      n <= 127 ? e++ : n <= 2047 ? e += 2 : n >= 55296 && n <= 57343 ? (e += 4, ++r) : e += 3;\n    }\n    return e;\n  }, we = globalThis.TextDecoder && new TextDecoder(), be = (t, e, r, n) => {\n    var a = e + r;\n    if (n) return a;\n    for (; t[e] && !(e >= a); ) ++e;\n    return e;\n  }, $e = function(t) {\n    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = arguments.length > 2 ? arguments[2] : void 0, n = arguments.length > 3 ? arguments[3] : void 0;\n    var a = be(t, e, r, n);\n    if (a - e > 16 && t.buffer && we)\n      return we.decode(t.subarray(e, a));\n    for (var i = \"\"; e < a; ) {\n      var s = t[e++];\n      if (!(s & 128)) {\n        i += String.fromCharCode(s);\n        continue;\n      }\n      var u = t[e++] & 63;\n      if ((s & 224) == 192) {\n        i += String.fromCharCode((s & 31) << 6 | u);\n        continue;\n      }\n      var c = t[e++] & 63;\n      if ((s & 240) == 224 ? s = (s & 15) << 12 | u << 6 | c : s = (s & 7) << 18 | u << 12 | c << 6 | t[e++] & 63, s < 65536)\n        i += String.fromCharCode(s);\n      else {\n        var h = s - 65536;\n        i += String.fromCharCode(55296 | h >> 10, 56320 | h & 1023);\n      }\n    }\n    return i;\n  }, fn = (t, e, r) => t ? $e(W, t, e, r) : \"\", hn = (t, e) => {\n    e = F(e), j(t, {\n      name: e,\n      fromWireType(r) {\n        var n = T[r >> 2], a = r + 4, i;\n        return i = fn(a, n, !0), z(r), i;\n      },\n      toWireType(r, n) {\n        n instanceof ArrayBuffer && (n = new Uint8Array(n));\n        var a, i = typeof n == \"string\";\n        i || ArrayBuffer.isView(n) && n.BYTES_PER_ELEMENT == 1 || $(\"Cannot pass non-string to std::string\"), i ? a = ge(n) : a = n.length;\n        var s = Xt(4 + a + 1), u = s + 4;\n        return T[s >> 2] = a, i ? rt(n, u, a + 1) : W.set(n, u), r !== null && r.push(z, s), s;\n      },\n      readValueFromPointer: it,\n      destructorFunction(r) {\n        z(r);\n      }\n    });\n  }, Ce = globalThis.TextDecoder ? new TextDecoder(\"utf-16le\") : void 0, dn = (t, e, r) => {\n    var n = t >> 1, a = be(at, n, e / 2, r);\n    if (a - n > 16 && Ce) return Ce.decode(at.subarray(n, a));\n    for (var i = \"\", s = n; s < a; ++s) {\n      var u = at[s];\n      i += String.fromCharCode(u);\n    }\n    return i;\n  }, pn = (t, e, r) => {\n    if (r != null || (r = 2147483647), r < 2) return 0;\n    r -= 2;\n    for (var n = e, a = r < t.length * 2 ? r / 2 : t.length, i = 0; i < a; ++i) {\n      var s = t.charCodeAt(i);\n      dt[e >> 1] = s, e += 2;\n    }\n    return dt[e >> 1] = 0, e - n;\n  }, yn = (t) => t.length * 2, vn = (t, e, r) => {\n    for (var n = \"\", a = t >> 2, i = 0; !(i >= e / 4); i++) {\n      var s = T[a + i];\n      if (!s && !r) break;\n      n += String.fromCodePoint(s);\n    }\n    return n;\n  }, mn = (t, e, r) => {\n    if (r != null || (r = 2147483647), r < 4) return 0;\n    for (var n = e, a = n + r - 4, i = 0; i < t.length; ++i) {\n      var s = t.codePointAt(i);\n      if (s > 65535 && i++, ot[e >> 2] = s, e += 4, e + 4 > a) break;\n    }\n    return ot[e >> 2] = 0, e - n;\n  }, gn = (t) => {\n    for (var e = 0, r = 0; r < t.length; ++r) {\n      var n = t.codePointAt(r);\n      n > 65535 && r++, e += 4;\n    }\n    return e;\n  }, wn = (t, e, r) => {\n    r = F(r);\n    var n, a, i;\n    e === 2 ? (n = dn, a = pn, i = yn) : (n = vn, a = mn, i = gn), j(t, {\n      name: r,\n      fromWireType: (s) => {\n        var u = T[s >> 2], c = n(s + 4, u * e, !0);\n        return z(s), c;\n      },\n      toWireType: (s, u) => {\n        typeof u != \"string\" && $(`Cannot pass non-string to C++ string type ${r}`);\n        var c = i(u), h = Xt(4 + c + e);\n        return T[h >> 2] = c / e, a(u, h + 4, c + e), s !== null && s.push(z, h), h;\n      },\n      readValueFromPointer: it,\n      destructorFunction(s) {\n        z(s);\n      }\n    });\n  }, bn = (t, e, r, n, a, i) => {\n    gt[t] = {\n      name: F(e),\n      rawConstructor: L(r, n),\n      rawDestructor: L(a, i),\n      fields: []\n    };\n  }, $n = (t, e, r, n, a, i, s, u, c, h) => {\n    gt[t].fields.push({\n      fieldName: F(e),\n      getterReturnType: r,\n      getter: L(n, a),\n      getterContext: i,\n      setterArgumentType: s,\n      setter: L(u, c),\n      setterContext: h\n    });\n  }, Cn = (t, e) => {\n    e = F(e), j(t, {\n      isVoid: !0,\n      name: e,\n      fromWireType: () => {\n      },\n      toWireType: (r, n) => {\n      }\n    });\n  }, zt = [], Tn = (t) => {\n    var e = zt.length;\n    return zt.push(t), e;\n  }, En = (t, e) => {\n    var r = Z[t];\n    return r === void 0 && $(`${e} has unknown type ${pe(t)}`), r;\n  }, Pn = (t, e) => {\n    for (var r = new Array(t), n = 0; n < t; ++n)\n      r[n] = En(T[e + n * 4 >> 2], `parameter ${n}`);\n    return r;\n  }, On = (t, e, r) => {\n    var n = [], a = t(n, r);\n    return n.length && (T[e >> 2] = B.toHandle(n)), a;\n  }, _n = {}, Te = (t) => {\n    var e = _n[t];\n    return e === void 0 ? F(t) : e;\n  }, xn = (t, e, r) => {\n    var n = 8, [a, ...i] = Pn(t, e), s = a.toWireType.bind(a), u = i.map((y) => y.readValueFromPointer.bind(y));\n    t--;\n    var c = new Array(t), h = (y, C, P, S) => {\n      for (var x = 0, O = 0; O < t; ++O)\n        c[O] = u[O](S + x), x += n;\n      var E;\n      switch (r) {\n        case 0:\n          E = B.toValue(y).apply(null, c);\n          break;\n        case 2:\n          E = Reflect.construct(B.toValue(y), c);\n          break;\n        case 3:\n          E = c[0];\n          break;\n        case 1:\n          E = B.toValue(y)[Te(C)](...c);\n          break;\n      }\n      return On(s, P, E);\n    }, p = `methodCaller<(${i.map((y) => y.name)}) => ${a.name}>`;\n    return Tn(Ut(p, h));\n  }, Sn = (t) => t ? (t = Te(t), B.toHandle(globalThis[t])) : B.toHandle(globalThis), In = (t) => {\n    t > 9 && (J[t + 1] += 1);\n  }, Dn = (t, e, r, n, a) => zt[t](e, r, n, a), Mn = (t) => {\n    var e = B.toValue(t);\n    Lt(e), Nt(t);\n  }, An = (t, e, r, n) => {\n    var a = (/* @__PURE__ */ new Date()).getFullYear(), i = new Date(a, 0, 1), s = new Date(a, 6, 1), u = i.getTimezoneOffset(), c = s.getTimezoneOffset(), h = Math.max(u, c);\n    T[t >> 2] = h * 60, ot[e >> 2] = +(u != c);\n    var p = (P) => {\n      var S = P >= 0 ? \"-\" : \"+\", x = Math.abs(P), O = String(Math.floor(x / 60)).padStart(2, \"0\"), E = String(x % 60).padStart(2, \"0\");\n      return `UTC${S}${O}${E}`;\n    }, y = p(u), C = p(c);\n    c < u ? (rt(y, r, 17), rt(C, n, 17)) : (rt(y, n, 17), rt(C, r, 17));\n  }, Fn = () => 2147483648, Rn = (t, e) => Math.ceil(t / e) * e, Ln = (t) => {\n    var e = Pt.buffer.byteLength, r = (t - e + 65535) / 65536 | 0;\n    try {\n      return Pt.grow(r), re(), 1;\n    } catch {\n    }\n  }, jn = (t) => {\n    var e = W.length;\n    t >>>= 0;\n    var r = Fn();\n    if (t > r)\n      return !1;\n    for (var n = 1; n <= 4; n *= 2) {\n      var a = e * (1 + 0.2 / n);\n      a = Math.min(a, t + 100663296);\n      var i = Math.min(r, Rn(Math.max(t, a), 65536)), s = Ln(i);\n      if (s)\n        return !0;\n    }\n    return !1;\n  }, Gt = {}, Bn = () => _ || \"./this.program\", ct = () => {\n    if (!ct.strings) {\n      var t = (typeof navigator == \"object\" && navigator.language || \"C\").replace(\"-\", \"_\") + \".UTF-8\", e = {\n        USER: \"web_user\",\n        LOGNAME: \"web_user\",\n        PATH: \"/\",\n        PWD: \"/\",\n        HOME: \"/home/web_user\",\n        LANG: t,\n        _: Bn()\n      };\n      for (var r in Gt)\n        Gt[r] === void 0 ? delete e[r] : e[r] = Gt[r];\n      var n = [];\n      for (var r in e)\n        n.push(`${r}=${e[r]}`);\n      ct.strings = n;\n    }\n    return ct.strings;\n  }, Un = (t, e) => {\n    var r = 0, n = 0;\n    for (var a of ct()) {\n      var i = e + r;\n      T[t + n >> 2] = i, r += rt(a, i, 1 / 0) + 1, n += 4;\n    }\n    return 0;\n  }, Vn = (t, e) => {\n    var r = ct();\n    T[t >> 2] = r.length;\n    var n = 0;\n    for (var a of r)\n      n += ge(a) + 1;\n    return T[e >> 2] = n, 0;\n  }, Wn = (t) => 52;\n  function Hn(t, e, r, n, a) {\n    return 70;\n  }\n  var kn = [null, [], []], Nn = (t, e) => {\n    var r = kn[t];\n    e === 0 || e === 10 ? ((t === 1 ? nt : V)($e(r)), r.length = 0) : r.push(e);\n  }, zn = (t, e, r, n) => {\n    for (var a = 0, i = 0; i < r; i++) {\n      var s = T[e >> 2], u = T[e + 4 >> 2];\n      e += 8;\n      for (var c = 0; c < u; c++)\n        Nn(t, W[s + c]);\n      a += u;\n    }\n    return T[n >> 2] = a, 0;\n  }, Gn = (t) => t;\n  if (Ar(), zr(), f.noExitRuntime && f.noExitRuntime, f.print && (nt = f.print), f.printErr && (V = f.printErr), f.wasmBinary && (q = f.wasmBinary), f.arguments && f.arguments, f.thisProgram && (_ = f.thisProgram), f.preInit)\n    for (typeof f.preInit == \"function\" && (f.preInit = [f.preInit]); f.preInit.length > 0; )\n      f.preInit.shift()();\n  var Ee, z, Xt, Pe, v, Oe, _e, xe, Se, Ie, De, Me, Ae, Pt, Fe;\n  function Xn(t) {\n    Ee = t.ya, z = f._free = t.za, Xt = f._malloc = t.Ba, Pe = t.Ca, v = t.Da, Oe = t.Ea, _e = t.Fa, xe = t.Ga, Se = t.Ha, Ie = t.Ia, De = t.Ja, N.viijii = t.Ka, Me = N.iiijj = t.La, N.jiji = t.Ma, Ae = N.jiiii = t.Na, N.iiiiij = t.Oa, N.iiiiijj = t.Pa, N.iiiiiijj = t.Qa, Pt = t.wa, Fe = t.Aa;\n  }\n  var qn = {\n    s: vr,\n    w: mr,\n    a: gr,\n    j: wr,\n    m: br,\n    Q: $r,\n    p: Cr,\n    U: Tr,\n    d: Er,\n    ca: Pr,\n    ta: _r,\n    ba: xr,\n    oa: Ir,\n    ra: Zr,\n    qa: Jr,\n    H: Kr,\n    ma: tn,\n    X: rn,\n    Y: nn,\n    x: on,\n    t: sn,\n    sa: cn,\n    na: hn,\n    R: wn,\n    I: bn,\n    ua: $n,\n    pa: Cn,\n    N: xn,\n    va: Nt,\n    D: Sn,\n    S: In,\n    M: Dn,\n    ia: Mn,\n    da: An,\n    ga: jn,\n    ea: Un,\n    fa: Vn,\n    ha: Wn,\n    $: Hn,\n    V: zn,\n    K: ma,\n    C: ba,\n    Z: ea,\n    T: Oa,\n    r: da,\n    b: Kn,\n    E: va,\n    ka: Ca,\n    c: ra,\n    ja: Ta,\n    h: ta,\n    i: oa,\n    q: ca,\n    P: ya,\n    v: fa,\n    F: ha,\n    L: pa,\n    z: $a,\n    J: _a,\n    aa: xa,\n    _: Sa,\n    f: na,\n    l: Yn,\n    e: Jn,\n    g: Qn,\n    O: Pa,\n    k: Zn,\n    la: ga,\n    o: la,\n    B: ia,\n    u: wa,\n    W: ua,\n    A: Ea,\n    n: aa,\n    G: sa,\n    y: Gn\n  };\n  function Yn(t, e) {\n    var r = g();\n    try {\n      w(t)(e);\n    } catch (n) {\n      if (m(r), n !== n + 0) throw n;\n      v(1, 0);\n    }\n  }\n  function Zn(t, e, r, n, a) {\n    var i = g();\n    try {\n      w(t)(e, r, n, a);\n    } catch (s) {\n      if (m(i), s !== s + 0) throw s;\n      v(1, 0);\n    }\n  }\n  function Qn(t, e, r, n) {\n    var a = g();\n    try {\n      w(t)(e, r, n);\n    } catch (i) {\n      if (m(a), i !== i + 0) throw i;\n      v(1, 0);\n    }\n  }\n  function Jn(t, e, r) {\n    var n = g();\n    try {\n      w(t)(e, r);\n    } catch (a) {\n      if (m(n), a !== a + 0) throw a;\n      v(1, 0);\n    }\n  }\n  function Kn(t, e) {\n    var r = g();\n    try {\n      return w(t)(e);\n    } catch (n) {\n      if (m(r), n !== n + 0) throw n;\n      v(1, 0);\n    }\n  }\n  function ta(t, e, r, n) {\n    var a = g();\n    try {\n      return w(t)(e, r, n);\n    } catch (i) {\n      if (m(a), i !== i + 0) throw i;\n      v(1, 0);\n    }\n  }\n  function ea(t, e, r, n, a, i) {\n    var s = g();\n    try {\n      return w(t)(e, r, n, a, i);\n    } catch (u) {\n      if (m(s), u !== u + 0) throw u;\n      v(1, 0);\n    }\n  }\n  function ra(t, e, r) {\n    var n = g();\n    try {\n      return w(t)(e, r);\n    } catch (a) {\n      if (m(n), a !== a + 0) throw a;\n      v(1, 0);\n    }\n  }\n  function na(t) {\n    var e = g();\n    try {\n      w(t)();\n    } catch (r) {\n      if (m(e), r !== r + 0) throw r;\n      v(1, 0);\n    }\n  }\n  function aa(t, e, r, n, a, i, s, u, c, h, p) {\n    var y = g();\n    try {\n      w(t)(e, r, n, a, i, s, u, c, h, p);\n    } catch (C) {\n      if (m(y), C !== C + 0) throw C;\n      v(1, 0);\n    }\n  }\n  function oa(t, e, r, n, a) {\n    var i = g();\n    try {\n      return w(t)(e, r, n, a);\n    } catch (s) {\n      if (m(i), s !== s + 0) throw s;\n      v(1, 0);\n    }\n  }\n  function ia(t, e, r, n, a, i, s) {\n    var u = g();\n    try {\n      w(t)(e, r, n, a, i, s);\n    } catch (c) {\n      if (m(u), c !== c + 0) throw c;\n      v(1, 0);\n    }\n  }\n  function sa(t, e, r, n, a, i, s, u, c, h, p, y, C, P, S, x) {\n    var O = g();\n    try {\n      w(t)(e, r, n, a, i, s, u, c, h, p, y, C, P, S, x);\n    } catch (E) {\n      if (m(O), E !== E + 0) throw E;\n      v(1, 0);\n    }\n  }\n  function ua(t, e, r, n, a, i, s, u, c) {\n    var h = g();\n    try {\n      w(t)(e, r, n, a, i, s, u, c);\n    } catch (p) {\n      if (m(h), p !== p + 0) throw p;\n      v(1, 0);\n    }\n  }\n  function ca(t, e, r, n, a, i) {\n    var s = g();\n    try {\n      return w(t)(e, r, n, a, i);\n    } catch (u) {\n      if (m(s), u !== u + 0) throw u;\n      v(1, 0);\n    }\n  }\n  function la(t, e, r, n, a, i) {\n    var s = g();\n    try {\n      w(t)(e, r, n, a, i);\n    } catch (u) {\n      if (m(s), u !== u + 0) throw u;\n      v(1, 0);\n    }\n  }\n  function fa(t, e, r, n, a, i, s) {\n    var u = g();\n    try {\n      return w(t)(e, r, n, a, i, s);\n    } catch (c) {\n      if (m(u), c !== c + 0) throw c;\n      v(1, 0);\n    }\n  }\n  function ha(t, e, r, n, a, i, s, u) {\n    var c = g();\n    try {\n      return w(t)(e, r, n, a, i, s, u);\n    } catch (h) {\n      if (m(c), h !== h + 0) throw h;\n      v(1, 0);\n    }\n  }\n  function da(t) {\n    var e = g();\n    try {\n      return w(t)();\n    } catch (r) {\n      if (m(e), r !== r + 0) throw r;\n      v(1, 0);\n    }\n  }\n  function pa(t, e, r, n, a, i, s, u, c) {\n    var h = g();\n    try {\n      return w(t)(e, r, n, a, i, s, u, c);\n    } catch (p) {\n      if (m(h), p !== p + 0) throw p;\n      v(1, 0);\n    }\n  }\n  function ya(t, e, r, n, a, i, s) {\n    var u = g();\n    try {\n      return w(t)(e, r, n, a, i, s);\n    } catch (c) {\n      if (m(u), c !== c + 0) throw c;\n      v(1, 0);\n    }\n  }\n  function va(t, e, r, n) {\n    var a = g();\n    try {\n      return w(t)(e, r, n);\n    } catch (i) {\n      if (m(a), i !== i + 0) throw i;\n      v(1, 0);\n    }\n  }\n  function ma(t, e, r, n) {\n    var a = g();\n    try {\n      return w(t)(e, r, n);\n    } catch (i) {\n      if (m(a), i !== i + 0) throw i;\n      v(1, 0);\n    }\n  }\n  function ga(t, e, r, n, a, i, s, u) {\n    var c = g();\n    try {\n      w(t)(e, r, n, a, i, s, u);\n    } catch (h) {\n      if (m(c), h !== h + 0) throw h;\n      v(1, 0);\n    }\n  }\n  function wa(t, e, r, n, a, i, s, u) {\n    var c = g();\n    try {\n      w(t)(e, r, n, a, i, s, u);\n    } catch (h) {\n      if (m(c), h !== h + 0) throw h;\n      v(1, 0);\n    }\n  }\n  function ba(t, e, r, n, a, i) {\n    var s = g();\n    try {\n      return w(t)(e, r, n, a, i);\n    } catch (u) {\n      if (m(s), u !== u + 0) throw u;\n      v(1, 0);\n    }\n  }\n  function $a(t, e, r, n, a, i, s, u, c, h) {\n    var p = g();\n    try {\n      return w(t)(e, r, n, a, i, s, u, c, h);\n    } catch (y) {\n      if (m(p), y !== y + 0) throw y;\n      v(1, 0);\n    }\n  }\n  function Ca(t, e, r) {\n    var n = g();\n    try {\n      return w(t)(e, r);\n    } catch (a) {\n      if (m(n), a !== a + 0) throw a;\n      v(1, 0);\n    }\n  }\n  function Ta(t, e, r, n, a) {\n    var i = g();\n    try {\n      return w(t)(e, r, n, a);\n    } catch (s) {\n      if (m(i), s !== s + 0) throw s;\n      v(1, 0);\n    }\n  }\n  function Ea(t, e, r, n, a, i, s, u, c, h) {\n    var p = g();\n    try {\n      w(t)(e, r, n, a, i, s, u, c, h);\n    } catch (y) {\n      if (m(p), y !== y + 0) throw y;\n      v(1, 0);\n    }\n  }\n  function Pa(t, e, r, n, a, i, s) {\n    var u = g();\n    try {\n      w(t)(e, r, n, a, i, s);\n    } catch (c) {\n      if (m(u), c !== c + 0) throw c;\n      v(1, 0);\n    }\n  }\n  function Oa(t, e, r, n) {\n    var a = g();\n    try {\n      return w(t)(e, r, n);\n    } catch (i) {\n      if (m(a), i !== i + 0) throw i;\n      v(1, 0);\n    }\n  }\n  function _a(t, e, r, n, a, i, s, u, c, h, p, y) {\n    var C = g();\n    try {\n      return w(t)(e, r, n, a, i, s, u, c, h, p, y);\n    } catch (P) {\n      if (m(C), P !== P + 0) throw P;\n      v(1, 0);\n    }\n  }\n  function xa(t, e, r, n, a, i, s) {\n    var u = g();\n    try {\n      return Me(t, e, r, n, a, i, s);\n    } catch (c) {\n      if (m(u), c !== c + 0) throw c;\n      v(1, 0);\n    }\n  }\n  function Sa(t, e, r, n, a) {\n    var i = g();\n    try {\n      return Ae(t, e, r, n, a);\n    } catch (s) {\n      if (m(i), s !== s + 0) throw s;\n      v(1, 0);\n    }\n  }\n  function Ia() {\n    ar();\n    function t() {\n      var e, r;\n      f.calledRun = !0, !ht && (or(), (e = Qt) === null || e === void 0 || e(f), (r = f.onRuntimeInitialized) === null || r === void 0 || r.call(f), ir());\n    }\n    f.setStatus ? (f.setStatus(\"Running...\"), setTimeout(() => {\n      setTimeout(() => f.setStatus(\"\"), 1), t();\n    }, 1)) : t();\n  }\n  var lt;\n  return lt = await dr(), Ia(), ee ? l = f : l = new Promise((t, e) => {\n    Qt = t, Jt = e;\n  }), l;\n}\nfunction qe(o) {\n  return Xe(Zt, o);\n}\nfunction mo() {\n  return qa(Zt);\n}\nfunction go(o) {\n  qe({\n    overrides: o,\n    equalityFn: Object.is,\n    fireImmediately: !1\n  });\n}\nasync function Za(o, l) {\n  return Ya(Zt, o, l);\n}\nconst wo = \"85d46f55d7c86a4d09bb04273367408b19c324f582d040d018aecb25a9a82942\", Ye = [\n  [\"aztec\", \"Aztec\"],\n  [\"code_128\", \"Code128\"],\n  [\"code_39\", \"Code39\"],\n  [\"code_93\", \"Code93\"],\n  [\"codabar\", \"Codabar\"],\n  [\"databar\", \"DataBar\"],\n  [\"databar_expanded\", \"DataBarExpanded\"],\n  [\"databar_limited\", \"DataBarLimited\"],\n  [\"data_matrix\", \"DataMatrix\"],\n  [\"dx_film_edge\", \"DXFilmEdge\"],\n  [\"ean_13\", \"EAN-13\"],\n  [\"ean_8\", \"EAN-8\"],\n  [\"itf\", \"ITF\"],\n  [\"maxi_code\", \"MaxiCode\"],\n  [\"micro_qr_code\", \"MicroQRCode\"],\n  [\"pdf417\", \"PDF417\"],\n  [\"qr_code\", \"QRCode\"],\n  [\"rm_qr_code\", \"rMQRCode\"],\n  [\"upc_a\", \"UPC-A\"],\n  [\"upc_e\", \"UPC-E\"],\n  [\"linear_codes\", \"Linear-Codes\"],\n  [\"matrix_codes\", \"Matrix-Codes\"],\n  [\"any\", \"Any\"]\n], Qa = [...Ye, [\"unknown\"]].map((o) => o[0]), Yt = new Map(\n  Ye\n);\nfunction Ja(o) {\n  for (const [l, d] of Yt)\n    if (o === d)\n      return l;\n  return \"unknown\";\n}\nfunction Ka(o) {\n  if (Ze(o))\n    return {\n      width: o.naturalWidth,\n      height: o.naturalHeight\n    };\n  if (Qe(o))\n    return {\n      width: o.width.baseVal.value,\n      height: o.height.baseVal.value\n    };\n  if (Je(o))\n    return {\n      width: o.videoWidth,\n      height: o.videoHeight\n    };\n  if (tr(o))\n    return {\n      width: o.width,\n      height: o.height\n    };\n  if (rr(o))\n    return {\n      width: o.displayWidth,\n      height: o.displayHeight\n    };\n  if (Ke(o))\n    return {\n      width: o.width,\n      height: o.height\n    };\n  if (er(o))\n    return {\n      width: o.width,\n      height: o.height\n    };\n  throw new TypeError(\n    \"The provided value is not of type '(Blob or HTMLCanvasElement or HTMLImageElement or HTMLVideoElement or ImageBitmap or ImageData or OffscreenCanvas or SVGImageElement or VideoFrame)'.\"\n  );\n}\nfunction Ze(o) {\n  var l, d;\n  try {\n    return o instanceof ((d = (l = o == null ? void 0 : o.ownerDocument) == null ? void 0 : l.defaultView) == null ? void 0 : d.HTMLImageElement);\n  } catch {\n    return !1;\n  }\n}\nfunction Qe(o) {\n  var l, d;\n  try {\n    return o instanceof ((d = (l = o == null ? void 0 : o.ownerDocument) == null ? void 0 : l.defaultView) == null ? void 0 : d.SVGImageElement);\n  } catch {\n    return !1;\n  }\n}\nfunction Je(o) {\n  var l, d;\n  try {\n    return o instanceof ((d = (l = o == null ? void 0 : o.ownerDocument) == null ? void 0 : l.defaultView) == null ? void 0 : d.HTMLVideoElement);\n  } catch {\n    return !1;\n  }\n}\nfunction Ke(o) {\n  var l, d;\n  try {\n    return o instanceof ((d = (l = o == null ? void 0 : o.ownerDocument) == null ? void 0 : l.defaultView) == null ? void 0 : d.HTMLCanvasElement);\n  } catch {\n    return !1;\n  }\n}\nfunction tr(o) {\n  try {\n    return o instanceof ImageBitmap || Object.prototype.toString.call(o) === \"[object ImageBitmap]\";\n  } catch {\n    return !1;\n  }\n}\nfunction er(o) {\n  try {\n    return o instanceof OffscreenCanvas || Object.prototype.toString.call(o) === \"[object OffscreenCanvas]\";\n  } catch {\n    return !1;\n  }\n}\nfunction rr(o) {\n  try {\n    return o instanceof VideoFrame || Object.prototype.toString.call(o) === \"[object VideoFrame]\";\n  } catch {\n    return !1;\n  }\n}\nfunction to(o) {\n  try {\n    return o instanceof Blob || Object.prototype.toString.call(o) === \"[object Blob]\";\n  } catch {\n    return !1;\n  }\n}\nfunction eo(o) {\n  try {\n    return o instanceof ImageData || Object.prototype.toString.call(o) === \"[object ImageData]\";\n  } catch {\n    return !1;\n  }\n}\nfunction ro(o, l) {\n  try {\n    const d = new OffscreenCanvas(o, l);\n    if (d.getContext(\"2d\") instanceof OffscreenCanvasRenderingContext2D)\n      return d;\n    throw void 0;\n  } catch {\n    const d = document.createElement(\"canvas\");\n    return d.width = o, d.height = l, d;\n  }\n}\nasync function nr(o) {\n  if (Ze(o) && !await io(o))\n    throw new DOMException(\n      \"Failed to load or decode HTMLImageElement.\",\n      \"InvalidStateError\"\n    );\n  if (Qe(o) && !await so(o))\n    throw new DOMException(\n      \"Failed to load or decode SVGImageElement.\",\n      \"InvalidStateError\"\n    );\n  if (rr(o) && uo(o))\n    throw new DOMException(\"VideoFrame is closed.\", \"InvalidStateError\");\n  if (Je(o) && (o.readyState === 0 || o.readyState === 1))\n    throw new DOMException(\"Invalid element or state.\", \"InvalidStateError\");\n  if (tr(o) && lo(o))\n    throw new DOMException(\n      \"The image source is detached.\",\n      \"InvalidStateError\"\n    );\n  const { width: l, height: d } = Ka(o);\n  if (l === 0 || d === 0)\n    return null;\n  const f = ro(l, d).getContext(\"2d\");\n  f.drawImage(o, 0, 0);\n  try {\n    return f.getImageData(0, 0, l, d);\n  } catch {\n    throw new DOMException(\"Source would taint origin.\", \"SecurityError\");\n  }\n}\nasync function no(o) {\n  let l;\n  try {\n    l = await createImageBitmap(o);\n  } catch {\n    try {\n      if (globalThis.Image) {\n        l = new Image();\n        let f = \"\";\n        try {\n          f = URL.createObjectURL(o), l.src = f, await l.decode();\n        } finally {\n          URL.revokeObjectURL(f);\n        }\n      } else\n        return o;\n    } catch {\n      throw new DOMException(\n        \"Failed to load or decode Blob.\",\n        \"InvalidStateError\"\n      );\n    }\n  }\n  return await nr(l);\n}\nfunction ao(o) {\n  const { width: l, height: d } = o;\n  if (l === 0 || d === 0)\n    return null;\n  const b = o.getContext(\"2d\");\n  try {\n    return b.getImageData(0, 0, l, d);\n  } catch {\n    throw new DOMException(\"Source would taint origin.\", \"SecurityError\");\n  }\n}\nasync function oo(o) {\n  if (to(o))\n    return await no(o);\n  if (eo(o)) {\n    if (co(o))\n      throw new DOMException(\n        \"The image data has been detached.\",\n        \"InvalidStateError\"\n      );\n    return o;\n  }\n  return Ke(o) || er(o) ? ao(o) : await nr(o);\n}\nasync function io(o) {\n  try {\n    return await o.decode(), !0;\n  } catch {\n    return !1;\n  }\n}\nasync function so(o) {\n  var l;\n  try {\n    return await ((l = o.decode) == null ? void 0 : l.call(o)), !0;\n  } catch {\n    return !1;\n  }\n}\nfunction uo(o) {\n  return o.format === null;\n}\nfunction co(o) {\n  return o.data.buffer.byteLength === 0;\n}\nfunction lo(o) {\n  return o.width === 0 && o.height === 0;\n}\nfunction Ge(o, l) {\n  return fo(o) ? new DOMException(`${l}: ${o.message}`, o.name) : ho(o) ? new o.constructor(`${l}: ${o.message}`) : new Error(`${l}: ${o}`);\n}\nfunction fo(o) {\n  return o instanceof DOMException || Object.prototype.toString.call(o) === \"[object DOMException]\";\n}\nfunction ho(o) {\n  return o instanceof Error || Object.prototype.toString.call(o) === \"[object Error]\";\n}\nvar ft;\nclass bo {\n  constructor(l = {}) {\n    He(this, ft);\n    var d;\n    try {\n      const b = (d = l == null ? void 0 : l.formats) == null ? void 0 : d.filter(\n        (f) => f !== \"unknown\"\n      );\n      if ((b == null ? void 0 : b.length) === 0)\n        throw new TypeError(\"Hint option provided, but is empty.\");\n      for (const f of b != null ? b : [])\n        if (!Yt.has(f))\n          throw new TypeError(\n            `Failed to read the 'formats' property from 'BarcodeDetectorOptions': The provided value '${f}' is not a valid enum value of type BarcodeFormat.`\n          );\n      ke(this, ft, b != null ? b : []), qe({ fireImmediately: !0 }).catch(() => {\n      });\n    } catch (b) {\n      throw Ge(\n        b,\n        \"Failed to construct 'BarcodeDetector'\"\n      );\n    }\n  }\n  static async getSupportedFormats() {\n    return Qa.filter((l) => l !== \"unknown\");\n  }\n  async detect(l) {\n    try {\n      const d = await oo(l);\n      if (d === null)\n        return [];\n      let b;\n      const f = {\n        tryCode39ExtendedMode: !1,\n        textMode: \"Plain\",\n        formats: We(this, ft).map((I) => Yt.get(I))\n      };\n      try {\n        b = await Za(d, f);\n      } catch (I) {\n        throw console.error(I), new DOMException(\n          \"Barcode detection service unavailable.\",\n          \"NotSupportedError\"\n        );\n      }\n      return b.map((I) => {\n        const {\n          topLeft: { x: D, y: M },\n          topRight: { x: _, y: A },\n          bottomLeft: { x: U, y: G },\n          bottomRight: { x: tt, y: X }\n        } = I.position, nt = Math.min(D, _, U, tt), V = Math.min(M, A, G, X), q = Math.max(D, _, U, tt), ht = Math.max(M, A, G, X);\n        return {\n          boundingBox: new DOMRectReadOnly(\n            nt,\n            V,\n            q - nt,\n            ht - V\n          ),\n          rawValue: I.text,\n          format: Ja(I.format),\n          cornerPoints: [\n            {\n              x: D,\n              y: M\n            },\n            {\n              x: _,\n              y: A\n            },\n            {\n              x: tt,\n              y: X\n            },\n            {\n              x: U,\n              y: G\n            }\n          ]\n        };\n      });\n    } catch (d) {\n      throw Ge(\n        d,\n        \"Failed to execute 'detect' on 'BarcodeDetector'\"\n      );\n    }\n  }\n}\nft = new WeakMap();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmFyY29kZS1kZXRlY3Rvci9kaXN0L2VzL3BvbnlmaWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsS0FBSyxHQUFHLEVBQUU7QUFDbEY7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxpQkFBaUI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxrQkFBa0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNCQUFzQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzQkFBc0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxFQUFFLElBQUksVUFBVSwwQ0FBMEMsRUFBRSxJQUFJLFVBQVUsa0JBQWtCLEVBQUUsSUFBSSxFQUFFO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLEVBQUU7QUFDMUc7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQyxzQkFBc0IsWUFBWTtBQUNsQyx3QkFBd0IsWUFBWTtBQUNwQyx5QkFBeUI7QUFDekIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0UiLCJzb3VyY2VzIjpbIkU6XFxuaWdodFxcY2FtcHVzcGFzcy1mbG93LWRlbW9cXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXGJhcmNvZGUtZGV0ZWN0b3JcXGRpc3RcXGVzXFxwb255ZmlsbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgVWUgPSAobykgPT4ge1xuICB0aHJvdyBUeXBlRXJyb3Iobyk7XG59O1xudmFyIFZlID0gKG8sIGwsIGQpID0+IGwuaGFzKG8pIHx8IFVlKFwiQ2Fubm90IFwiICsgZCk7XG52YXIgV2UgPSAobywgbCwgZCkgPT4gKFZlKG8sIGwsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIiksIGQgPyBkLmNhbGwobykgOiBsLmdldChvKSksIEhlID0gKG8sIGwsIGQpID0+IGwuaGFzKG8pID8gVWUoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpIDogbCBpbnN0YW5jZW9mIFdlYWtTZXQgPyBsLmFkZChvKSA6IGwuc2V0KG8sIGQpLCBrZSA9IChvLCBsLCBkLCBiKSA9PiAoVmUobywgbCwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpLCBiID8gYi5jYWxsKG8sIGQpIDogbC5zZXQobywgZCksIGQpO1xuY29uc3QgRHQgPSBbXG4gIFtcIkF6dGVjXCIsIFwiTVwiXSxcbiAgW1wiQ29kYWJhclwiLCBcIkxcIl0sXG4gIFtcIkNvZGUzOVwiLCBcIkxcIl0sXG4gIFtcIkNvZGU5M1wiLCBcIkxcIl0sXG4gIFtcIkNvZGUxMjhcIiwgXCJMXCJdLFxuICBbXCJEYXRhQmFyXCIsIFwiTFwiXSxcbiAgW1wiRGF0YUJhckV4cGFuZGVkXCIsIFwiTFwiXSxcbiAgW1wiRGF0YU1hdHJpeFwiLCBcIk1cIl0sXG4gIFtcIkVBTi04XCIsIFwiTFwiXSxcbiAgW1wiRUFOLTEzXCIsIFwiTFwiXSxcbiAgW1wiSVRGXCIsIFwiTFwiXSxcbiAgW1wiTWF4aUNvZGVcIiwgXCJNXCJdLFxuICBbXCJQREY0MTdcIiwgXCJNXCJdLFxuICBbXCJRUkNvZGVcIiwgXCJNXCJdLFxuICBbXCJVUEMtQVwiLCBcIkxcIl0sXG4gIFtcIlVQQy1FXCIsIFwiTFwiXSxcbiAgW1wiTWljcm9RUkNvZGVcIiwgXCJNXCJdLFxuICBbXCJyTVFSQ29kZVwiLCBcIk1cIl0sXG4gIFtcIkRYRmlsbUVkZ2VcIiwgXCJMXCJdLFxuICBbXCJEYXRhQmFyTGltaXRlZFwiLCBcIkxcIl1cbl0sIE10ID0gRHQubWFwKChbb10pID0+IG8pLCBNYSA9IE10LmZpbHRlcihcbiAgKG8sIGwpID0+IER0W2xdWzFdID09PSBcIkxcIlxuKSwgQWEgPSBNdC5maWx0ZXIoXG4gIChvLCBsKSA9PiBEdFtsXVsxXSA9PT0gXCJNXCJcbik7XG5mdW5jdGlvbiBxdChvKSB7XG4gIHN3aXRjaCAobykge1xuICAgIGNhc2UgXCJMaW5lYXItQ29kZXNcIjpcbiAgICAgIHJldHVybiBNYS5yZWR1Y2UoKGwsIGQpID0+IGwgfCBxdChkKSwgMCk7XG4gICAgY2FzZSBcIk1hdHJpeC1Db2Rlc1wiOlxuICAgICAgcmV0dXJuIEFhLnJlZHVjZSgobCwgZCkgPT4gbCB8IHF0KGQpLCAwKTtcbiAgICBjYXNlIFwiQW55XCI6XG4gICAgICByZXR1cm4gKDEgPDwgRHQubGVuZ3RoKSAtIDE7XG4gICAgY2FzZSBcIk5vbmVcIjpcbiAgICAgIHJldHVybiAwO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gMSA8PCBNdC5pbmRleE9mKG8pO1xuICB9XG59XG5mdW5jdGlvbiBGYShvKSB7XG4gIGlmIChvID09PSAwKVxuICAgIHJldHVybiBcIk5vbmVcIjtcbiAgY29uc3QgbCA9IDMxIC0gTWF0aC5jbHozMihvKTtcbiAgcmV0dXJuIE10W2xdO1xufVxuZnVuY3Rpb24gUmEobykge1xuICByZXR1cm4gby5yZWR1Y2UoKGwsIGQpID0+IGwgfCBxdChkKSwgMCk7XG59XG5jb25zdCBMYSA9IFtcbiAgXCJMb2NhbEF2ZXJhZ2VcIixcbiAgXCJHbG9iYWxIaXN0b2dyYW1cIixcbiAgXCJGaXhlZFRocmVzaG9sZFwiLFxuICBcIkJvb2xDYXN0XCJcbl07XG5mdW5jdGlvbiBqYShvKSB7XG4gIHJldHVybiBMYS5pbmRleE9mKG8pO1xufVxuY29uc3QgTmUgPSBbXG4gIFwiVW5rbm93blwiLFxuICBcIkFTQ0lJXCIsXG4gIFwiSVNPODg1OV8xXCIsXG4gIFwiSVNPODg1OV8yXCIsXG4gIFwiSVNPODg1OV8zXCIsXG4gIFwiSVNPODg1OV80XCIsXG4gIFwiSVNPODg1OV81XCIsXG4gIFwiSVNPODg1OV82XCIsXG4gIFwiSVNPODg1OV83XCIsXG4gIFwiSVNPODg1OV84XCIsXG4gIFwiSVNPODg1OV85XCIsXG4gIFwiSVNPODg1OV8xMFwiLFxuICBcIklTTzg4NTlfMTFcIixcbiAgXCJJU084ODU5XzEzXCIsXG4gIFwiSVNPODg1OV8xNFwiLFxuICBcIklTTzg4NTlfMTVcIixcbiAgXCJJU084ODU5XzE2XCIsXG4gIFwiQ3A0MzdcIixcbiAgXCJDcDEyNTBcIixcbiAgXCJDcDEyNTFcIixcbiAgXCJDcDEyNTJcIixcbiAgXCJDcDEyNTZcIixcbiAgXCJTaGlmdF9KSVNcIixcbiAgXCJCaWc1XCIsXG4gIFwiR0IyMzEyXCIsXG4gIFwiR0IxODAzMFwiLFxuICBcIkVVQ19KUFwiLFxuICBcIkVVQ19LUlwiLFxuICBcIlVURjE2QkVcIixcbiAgLyoqXG4gICAqIFVuaWNvZGVCaWcgW1tkZXByZWNhdGVkXV1cbiAgICovXG4gIFwiVVRGMTZCRVwiLFxuICBcIlVURjhcIixcbiAgXCJVVEYxNkxFXCIsXG4gIFwiVVRGMzJCRVwiLFxuICBcIlVURjMyTEVcIixcbiAgXCJCSU5BUllcIlxuXTtcbmZ1bmN0aW9uIEJhKG8pIHtcbiAgcmV0dXJuIG8gPT09IFwiVW5pY29kZUJpZ1wiID8gTmUuaW5kZXhPZihcIlVURjE2QkVcIikgOiBOZS5pbmRleE9mKG8pO1xufVxuY29uc3QgVWEgPSBbXG4gIFwiVGV4dFwiLFxuICBcIkJpbmFyeVwiLFxuICBcIk1peGVkXCIsXG4gIFwiR1MxXCIsXG4gIFwiSVNPMTU0MzRcIixcbiAgXCJVbmtub3duRUNJXCJcbl07XG5mdW5jdGlvbiBWYShvKSB7XG4gIHJldHVybiBVYVtvXTtcbn1cbmNvbnN0IFdhID0gW1wiSWdub3JlXCIsIFwiUmVhZFwiLCBcIlJlcXVpcmVcIl07XG5mdW5jdGlvbiBIYShvKSB7XG4gIHJldHVybiBXYS5pbmRleE9mKG8pO1xufVxuY29uc3Qga2EgPSBbXCJQbGFpblwiLCBcIkVDSVwiLCBcIkhSSVwiLCBcIkhleFwiLCBcIkVzY2FwZWRcIl07XG5mdW5jdGlvbiBOYShvKSB7XG4gIHJldHVybiBrYS5pbmRleE9mKG8pO1xufVxuY29uc3QgSXQgPSB7XG4gIGZvcm1hdHM6IFtdLFxuICB0cnlIYXJkZXI6ICEwLFxuICB0cnlSb3RhdGU6ICEwLFxuICB0cnlJbnZlcnQ6ICEwLFxuICB0cnlEb3duc2NhbGU6ICEwLFxuICB0cnlEZW5vaXNlOiAhMSxcbiAgYmluYXJpemVyOiBcIkxvY2FsQXZlcmFnZVwiLFxuICBpc1B1cmU6ICExLFxuICBkb3duc2NhbGVGYWN0b3I6IDMsXG4gIGRvd25zY2FsZVRocmVzaG9sZDogNTAwLFxuICBtaW5MaW5lQ291bnQ6IDIsXG4gIG1heE51bWJlck9mU3ltYm9sczogMjU1LFxuICB0cnlDb2RlMzlFeHRlbmRlZE1vZGU6ICEwLFxuICByZXR1cm5FcnJvcnM6ICExLFxuICBlYW5BZGRPblN5bWJvbDogXCJJZ25vcmVcIixcbiAgdGV4dE1vZGU6IFwiSFJJXCIsXG4gIGNoYXJhY3RlclNldDogXCJVbmtub3duXCJcbn07XG5mdW5jdGlvbiB6ZShvKSB7XG4gIHJldHVybiB7XG4gICAgLi4ubyxcbiAgICBmb3JtYXRzOiBSYShvLmZvcm1hdHMpLFxuICAgIGJpbmFyaXplcjogamEoby5iaW5hcml6ZXIpLFxuICAgIGVhbkFkZE9uU3ltYm9sOiBIYShvLmVhbkFkZE9uU3ltYm9sKSxcbiAgICB0ZXh0TW9kZTogTmEoby50ZXh0TW9kZSksXG4gICAgY2hhcmFjdGVyU2V0OiBCYShvLmNoYXJhY3RlclNldClcbiAgfTtcbn1cbmZ1bmN0aW9uIHphKG8pIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5vLFxuICAgIGZvcm1hdDogRmEoby5mb3JtYXQpLFxuICAgIGNvbnRlbnRUeXBlOiBWYShvLmNvbnRlbnRUeXBlKSxcbiAgICBlY2NMZXZlbDogby5lY0xldmVsXG4gIH07XG59XG5jb25zdCB5byA9IFwiMi4yLjRcIiwgdm8gPSBcImZiYTRlOTUwM2ZlZTQ1MThjYTJlODk1MTBiYWVlYTliY2MzNmRjOGRcIiwgR2EgPSB7XG4gIGxvY2F0ZUZpbGU6IChvLCBsKSA9PiB7XG4gICAgY29uc3QgZCA9IG8ubWF0Y2goL18oLis/KVxcLndhc20kLyk7XG4gICAgcmV0dXJuIGQgPyBgaHR0cHM6Ly9mYXN0bHkuanNkZWxpdnIubmV0L25wbS96eGluZy13YXNtQDIuMi40L2Rpc3QvJHtkWzFdfS8ke299YCA6IGwgKyBvO1xuICB9XG59LCBTdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gWGEobywgbCkge1xuICByZXR1cm4gT2JqZWN0LmlzKG8sIGwpIHx8IE9iamVjdC5rZXlzKG8pLmxlbmd0aCA9PT0gT2JqZWN0LmtleXMobCkubGVuZ3RoICYmIE9iamVjdC5rZXlzKG8pLmV2ZXJ5KFxuICAgIChkKSA9PiBPYmplY3QuaGFzT3duKGwsIGQpICYmIG9bZF0gPT09IGxbZF1cbiAgKTtcbn1cbmZ1bmN0aW9uIFhlKG8sIHtcbiAgb3ZlcnJpZGVzOiBsLFxuICBlcXVhbGl0eUZuOiBkID0gWGEsXG4gIGZpcmVJbW1lZGlhdGVseTogYiA9ICExXG59ID0ge30pIHtcbiAgdmFyIGY7XG4gIGNvbnN0IFtJLCBEXSA9IChmID0gU3QuZ2V0KG8pKSAhPSBudWxsID8gZiA6IFtHYV0sIE0gPSBsICE9IG51bGwgPyBsIDogSTtcbiAgbGV0IF87XG4gIGlmIChiKSB7XG4gICAgaWYgKEQgJiYgKF8gPSBkKEksIE0pKSlcbiAgICAgIHJldHVybiBEO1xuICAgIGNvbnN0IEEgPSBvKHtcbiAgICAgIC4uLk1cbiAgICB9KTtcbiAgICByZXR1cm4gU3Quc2V0KG8sIFtNLCBBXSksIEE7XG4gIH1cbiAgKF8gIT0gbnVsbCA/IF8gOiBkKEksIE0pKSB8fCBTdC5zZXQobywgW01dKTtcbn1cbmZ1bmN0aW9uIHFhKG8pIHtcbiAgU3QuZGVsZXRlKG8pO1xufVxuYXN5bmMgZnVuY3Rpb24gWWEobywgbCwgZCA9IEl0KSB7XG4gIGNvbnN0IGIgPSB7XG4gICAgLi4uSXQsXG4gICAgLi4uZFxuICB9LCBmID0gYXdhaXQgWGUobywge1xuICAgIGZpcmVJbW1lZGlhdGVseTogITBcbiAgfSk7XG4gIGxldCBJLCBEO1xuICBpZiAoXCJ3aWR0aFwiIGluIGwgJiYgXCJoZWlnaHRcIiBpbiBsICYmIFwiZGF0YVwiIGluIGwpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiBfLFxuICAgICAgZGF0YTogeyBieXRlTGVuZ3RoOiBBIH0sXG4gICAgICB3aWR0aDogVSxcbiAgICAgIGhlaWdodDogR1xuICAgIH0gPSBsO1xuICAgIEQgPSBmLl9tYWxsb2MoQSksIGYuSEVBUFU4LnNldChfLCBEKSwgSSA9IGYucmVhZEJhcmNvZGVzRnJvbVBpeG1hcChcbiAgICAgIEQsXG4gICAgICBVLFxuICAgICAgRyxcbiAgICAgIHplKGIpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgXywgQTtcbiAgICBpZiAoXCJidWZmZXJcIiBpbiBsKVxuICAgICAgW18sIEFdID0gW2wuYnl0ZUxlbmd0aCwgbF07XG4gICAgZWxzZSBpZiAoXCJieXRlTGVuZ3RoXCIgaW4gbClcbiAgICAgIFtfLCBBXSA9IFtsLmJ5dGVMZW5ndGgsIG5ldyBVaW50OEFycmF5KGwpXTtcbiAgICBlbHNlIGlmIChcInNpemVcIiBpbiBsKVxuICAgICAgW18sIEFdID0gW2wuc2l6ZSwgbmV3IFVpbnQ4QXJyYXkoYXdhaXQgbC5hcnJheUJ1ZmZlcigpKV07XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZVwiKTtcbiAgICBEID0gZi5fbWFsbG9jKF8pLCBmLkhFQVBVOC5zZXQoQSwgRCksIEkgPSBmLnJlYWRCYXJjb2Rlc0Zyb21JbWFnZShcbiAgICAgIEQsXG4gICAgICBfLFxuICAgICAgemUoYilcbiAgICApO1xuICB9XG4gIGYuX2ZyZWUoRCk7XG4gIGNvbnN0IE0gPSBbXTtcbiAgZm9yIChsZXQgXyA9IDA7IF8gPCBJLnNpemUoKTsgKytfKVxuICAgIE0ucHVzaChcbiAgICAgIHphKEkuZ2V0KF8pKVxuICAgICk7XG4gIHJldHVybiBNO1xufVxuKHtcbiAgLi4uSXQsXG4gIGZvcm1hdHM6IFsuLi5JdC5mb3JtYXRzXVxufSk7XG5hc3luYyBmdW5jdGlvbiBadChvID0ge30pIHtcbiAgdmFyIGwsIGQsIGIsIGYgPSBvLCBJID0gISFnbG9iYWxUaGlzLndpbmRvdywgRCA9IHR5cGVvZiBCdW4gPCBcInVcIiwgTSA9ICEhZ2xvYmFsVGhpcy5Xb3JrZXJHbG9iYWxTY29wZTtcbiAgISgoZCA9IGdsb2JhbFRoaXMucHJvY2VzcykgPT09IG51bGwgfHwgZCA9PT0gdm9pZCAwIHx8IChkID0gZC52ZXJzaW9ucykgPT09IG51bGwgfHwgZCA9PT0gdm9pZCAwKSAmJiBkLm5vZGUgJiYgKChiID0gZ2xvYmFsVGhpcy5wcm9jZXNzKSA9PT0gbnVsbCB8fCBiID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiLnR5cGUpICE9IFwicmVuZGVyZXJcIjtcbiAgdmFyIF8gPSBcIi4vdGhpcy5wcm9ncmFtXCIsIEEsIFUgPSBcIlwiO1xuICBmdW5jdGlvbiBHKHQpIHtcbiAgICByZXR1cm4gZi5sb2NhdGVGaWxlID8gZi5sb2NhdGVGaWxlKHQsIFUpIDogVSArIHQ7XG4gIH1cbiAgdmFyIHR0LCBYO1xuICBpZiAoSSB8fCBNIHx8IEQpIHtcbiAgICB0cnkge1xuICAgICAgVSA9IG5ldyBVUkwoXCIuXCIsIEEpLmhyZWY7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIE0gJiYgKFggPSAodCkgPT4ge1xuICAgICAgdmFyIGUgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHJldHVybiBlLm9wZW4oXCJHRVRcIiwgdCwgITEpLCBlLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIiwgZS5zZW5kKG51bGwpLCBuZXcgVWludDhBcnJheShlLnJlc3BvbnNlKTtcbiAgICB9KSwgdHQgPSBhc3luYyAodCkgPT4ge1xuICAgICAgdmFyIGUgPSBhd2FpdCBmZXRjaCh0LCB7XG4gICAgICAgIGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCJcbiAgICAgIH0pO1xuICAgICAgaWYgKGUub2spXG4gICAgICAgIHJldHVybiBlLmFycmF5QnVmZmVyKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZS5zdGF0dXMgKyBcIiA6IFwiICsgZS51cmwpO1xuICAgIH07XG4gIH1cbiAgdmFyIG50ID0gY29uc29sZS5sb2cuYmluZChjb25zb2xlKSwgViA9IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKSwgcSwgaHQgPSAhMSwgUXQsIEp0LCBZLCBXLCBkdCwgYXQsIG90LCBULCBLdCwgdGUsIGVlID0gITE7XG4gIGZ1bmN0aW9uIHJlKCkge1xuICAgIHZhciB0ID0gUHQuYnVmZmVyO1xuICAgIFkgPSBuZXcgSW50OEFycmF5KHQpLCBkdCA9IG5ldyBJbnQxNkFycmF5KHQpLCBmLkhFQVBVOCA9IFcgPSBuZXcgVWludDhBcnJheSh0KSwgYXQgPSBuZXcgVWludDE2QXJyYXkodCksIG90ID0gbmV3IEludDMyQXJyYXkodCksIFQgPSBuZXcgVWludDMyQXJyYXkodCksIEt0ID0gbmV3IEZsb2F0MzJBcnJheSh0KSwgdGUgPSBuZXcgRmxvYXQ2NEFycmF5KHQpO1xuICB9XG4gIGZ1bmN0aW9uIGFyKCkge1xuICAgIGlmIChmLnByZVJ1bilcbiAgICAgIGZvciAodHlwZW9mIGYucHJlUnVuID09IFwiZnVuY3Rpb25cIiAmJiAoZi5wcmVSdW4gPSBbZi5wcmVSdW5dKTsgZi5wcmVSdW4ubGVuZ3RoOyApXG4gICAgICAgIHlyKGYucHJlUnVuLnNoaWZ0KCkpO1xuICAgIG5lKG9lKTtcbiAgfVxuICBmdW5jdGlvbiBvcigpIHtcbiAgICBlZSA9ICEwLCBsdC54YSgpO1xuICB9XG4gIGZ1bmN0aW9uIGlyKCkge1xuICAgIGlmIChmLnBvc3RSdW4pXG4gICAgICBmb3IgKHR5cGVvZiBmLnBvc3RSdW4gPT0gXCJmdW5jdGlvblwiICYmIChmLnBvc3RSdW4gPSBbZi5wb3N0UnVuXSk7IGYucG9zdFJ1bi5sZW5ndGg7IClcbiAgICAgICAgcHIoZi5wb3N0UnVuLnNoaWZ0KCkpO1xuICAgIG5lKGFlKTtcbiAgfVxuICBmdW5jdGlvbiBBdCh0KSB7XG4gICAgdmFyIGUsIHI7XG4gICAgKGUgPSBmLm9uQWJvcnQpID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCB8fCBlLmNhbGwoZiwgdCksIHQgPSBcIkFib3J0ZWQoXCIgKyB0ICsgXCIpXCIsIFYodCksIGh0ID0gITAsIHQgKz0gXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCI7XG4gICAgdmFyIG4gPSBuZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHQpO1xuICAgIHRocm93IChyID0gSnQpID09PSBudWxsIHx8IHIgPT09IHZvaWQgMCB8fCByKG4pLCBuO1xuICB9XG4gIHZhciBwdDtcbiAgZnVuY3Rpb24gc3IoKSB7XG4gICAgcmV0dXJuIEcoXCJ6eGluZ19yZWFkZXIud2FzbVwiKTtcbiAgfVxuICBmdW5jdGlvbiB1cih0KSB7XG4gICAgaWYgKHQgPT0gcHQgJiYgcSlcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShxKTtcbiAgICBpZiAoWClcbiAgICAgIHJldHVybiBYKHQpO1xuICAgIHRocm93IFwiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIjtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcih0KSB7XG4gICAgaWYgKCFxKVxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGUgPSBhd2FpdCB0dCh0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGUpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgcmV0dXJuIHVyKHQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxyKHQsIGUpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHIgPSBhd2FpdCBjcih0KSwgbiA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHIsIGUpO1xuICAgICAgcmV0dXJuIG47XG4gICAgfSBjYXRjaCAoYSkge1xuICAgICAgVihgZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJHthfWApLCBBdChhKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZnIodCwgZSwgcikge1xuICAgIGlmICghdCAmJiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZylcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuID0gZmV0Y2goZSwge1xuICAgICAgICAgIGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCJcbiAgICAgICAgfSksIGEgPSBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhuLCByKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGNhdGNoIChpKSB7XG4gICAgICAgIFYoYHdhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAke2l9YCksIFYoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKTtcbiAgICAgIH1cbiAgICByZXR1cm4gbHIoZSwgcik7XG4gIH1cbiAgZnVuY3Rpb24gaHIoKSB7XG4gICAgdmFyIHQgPSB7XG4gICAgICBhOiBxblxuICAgIH07XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZHIoKSB7XG4gICAgZnVuY3Rpb24gdChpLCBzKSB7XG4gICAgICByZXR1cm4gbHQgPSBpLmV4cG9ydHMsIFhuKGx0KSwgcmUoKSwgbHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGUoaSkge1xuICAgICAgcmV0dXJuIHQoaS5pbnN0YW5jZSk7XG4gICAgfVxuICAgIHZhciByID0gaHIoKTtcbiAgICBpZiAoZi5pbnN0YW50aWF0ZVdhc20pXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKGksIHMpID0+IHtcbiAgICAgICAgZi5pbnN0YW50aWF0ZVdhc20ociwgKHUsIGMpID0+IHtcbiAgICAgICAgICBpKHQodSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIHB0ICE9IG51bGwgfHwgKHB0ID0gc3IoKSk7XG4gICAgdmFyIG4gPSBhd2FpdCBmcihxLCBwdCwgciksIGEgPSBlKG4pO1xuICAgIHJldHVybiBhO1xuICB9XG4gIHZhciBuZSA9ICh0KSA9PiB7XG4gICAgZm9yICg7IHQubGVuZ3RoID4gMDsgKVxuICAgICAgdC5zaGlmdCgpKGYpO1xuICB9LCBhZSA9IFtdLCBwciA9ICh0KSA9PiBhZS5wdXNoKHQpLCBvZSA9IFtdLCB5ciA9ICh0KSA9PiBvZS5wdXNoKHQpLCBtID0gKHQpID0+IF9lKHQpLCBnID0gKCkgPT4geGUoKSwgeXQgPSBbXSwgdnQgPSAwLCB2ciA9ICh0KSA9PiB7XG4gICAgdmFyIGUgPSBuZXcgRnQodCk7XG4gICAgcmV0dXJuIGUuZ2V0X2NhdWdodCgpIHx8IChlLnNldF9jYXVnaHQoITApLCB2dC0tKSwgZS5zZXRfcmV0aHJvd24oITEpLCB5dC5wdXNoKGUpLCBJZSh0KSwgUGUodCk7XG4gIH0sIEggPSAwLCBtciA9ICgpID0+IHtcbiAgICB2KDAsIDApO1xuICAgIHZhciB0ID0geXQucG9wKCk7XG4gICAgU2UodC5leGNQdHIpLCBIID0gMDtcbiAgfTtcbiAgY2xhc3MgRnQge1xuICAgIGNvbnN0cnVjdG9yKGUpIHtcbiAgICAgIHRoaXMuZXhjUHRyID0gZSwgdGhpcy5wdHIgPSBlIC0gMjQ7XG4gICAgfVxuICAgIHNldF90eXBlKGUpIHtcbiAgICAgIFRbdGhpcy5wdHIgKyA0ID4+IDJdID0gZTtcbiAgICB9XG4gICAgZ2V0X3R5cGUoKSB7XG4gICAgICByZXR1cm4gVFt0aGlzLnB0ciArIDQgPj4gMl07XG4gICAgfVxuICAgIHNldF9kZXN0cnVjdG9yKGUpIHtcbiAgICAgIFRbdGhpcy5wdHIgKyA4ID4+IDJdID0gZTtcbiAgICB9XG4gICAgZ2V0X2Rlc3RydWN0b3IoKSB7XG4gICAgICByZXR1cm4gVFt0aGlzLnB0ciArIDggPj4gMl07XG4gICAgfVxuICAgIHNldF9jYXVnaHQoZSkge1xuICAgICAgZSA9IGUgPyAxIDogMCwgWVt0aGlzLnB0ciArIDEyXSA9IGU7XG4gICAgfVxuICAgIGdldF9jYXVnaHQoKSB7XG4gICAgICByZXR1cm4gWVt0aGlzLnB0ciArIDEyXSAhPSAwO1xuICAgIH1cbiAgICBzZXRfcmV0aHJvd24oZSkge1xuICAgICAgZSA9IGUgPyAxIDogMCwgWVt0aGlzLnB0ciArIDEzXSA9IGU7XG4gICAgfVxuICAgIGdldF9yZXRocm93bigpIHtcbiAgICAgIHJldHVybiBZW3RoaXMucHRyICsgMTNdICE9IDA7XG4gICAgfVxuICAgIGluaXQoZSwgcikge1xuICAgICAgdGhpcy5zZXRfYWRqdXN0ZWRfcHRyKDApLCB0aGlzLnNldF90eXBlKGUpLCB0aGlzLnNldF9kZXN0cnVjdG9yKHIpO1xuICAgIH1cbiAgICBzZXRfYWRqdXN0ZWRfcHRyKGUpIHtcbiAgICAgIFRbdGhpcy5wdHIgKyAxNiA+PiAyXSA9IGU7XG4gICAgfVxuICAgIGdldF9hZGp1c3RlZF9wdHIoKSB7XG4gICAgICByZXR1cm4gVFt0aGlzLnB0ciArIDE2ID4+IDJdO1xuICAgIH1cbiAgfVxuICB2YXIgbXQgPSAodCkgPT4gT2UodCksIFJ0ID0gKHQpID0+IHtcbiAgICB2YXIgZSA9IEg7XG4gICAgaWYgKCFlKVxuICAgICAgcmV0dXJuIG10KDApLCAwO1xuICAgIHZhciByID0gbmV3IEZ0KGUpO1xuICAgIHIuc2V0X2FkanVzdGVkX3B0cihlKTtcbiAgICB2YXIgbiA9IHIuZ2V0X3R5cGUoKTtcbiAgICBpZiAoIW4pXG4gICAgICByZXR1cm4gbXQoMCksIGU7XG4gICAgZm9yICh2YXIgYSBvZiB0KSB7XG4gICAgICBpZiAoYSA9PT0gMCB8fCBhID09PSBuKVxuICAgICAgICBicmVhaztcbiAgICAgIHZhciBpID0gci5wdHIgKyAxNjtcbiAgICAgIGlmIChEZShhLCBuLCBpKSlcbiAgICAgICAgcmV0dXJuIG10KGEpLCBlO1xuICAgIH1cbiAgICByZXR1cm4gbXQobiksIGU7XG4gIH0sIGdyID0gKCkgPT4gUnQoW10pLCB3ciA9ICh0KSA9PiBSdChbdF0pLCBiciA9ICh0LCBlKSA9PiBSdChbdCwgZV0pLCAkciA9ICgpID0+IHtcbiAgICB2YXIgdCA9IHl0LnBvcCgpO1xuICAgIHQgfHwgQXQoXCJubyBleGNlcHRpb24gdG8gdGhyb3dcIik7XG4gICAgdmFyIGUgPSB0LmV4Y1B0cjtcbiAgICB0aHJvdyB0LmdldF9yZXRocm93bigpIHx8ICh5dC5wdXNoKHQpLCB0LnNldF9yZXRocm93bighMCksIHQuc2V0X2NhdWdodCghMSksIHZ0KyspLCBIID0gZSwgSDtcbiAgfSwgQ3IgPSAodCwgZSwgcikgPT4ge1xuICAgIHZhciBuID0gbmV3IEZ0KHQpO1xuICAgIHRocm93IG4uaW5pdChlLCByKSwgSCA9IHQsIHZ0KyssIEg7XG4gIH0sIFRyID0gKCkgPT4gdnQsIEVyID0gKHQpID0+IHtcbiAgICB0aHJvdyBIIHx8IChIID0gdCksIEg7XG4gIH0sIFByID0gKCkgPT4gQXQoXCJcIiksIGd0ID0ge30sIEx0ID0gKHQpID0+IHtcbiAgICBmb3IgKDsgdC5sZW5ndGg7ICkge1xuICAgICAgdmFyIGUgPSB0LnBvcCgpLCByID0gdC5wb3AoKTtcbiAgICAgIHIoZSk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBpdCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKFRbdCA+PiAyXSk7XG4gIH1cbiAgdmFyIGV0ID0ge30sIFogPSB7fSwgd3QgPSB7fSwgT3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgICBzdXBlcih0KSwgdGhpcy5uYW1lID0gXCJJbnRlcm5hbEVycm9yXCI7XG4gICAgfVxuICB9LCBidCA9ICh0KSA9PiB7XG4gICAgdGhyb3cgbmV3IE9yKHQpO1xuICB9LCBRID0gKHQsIGUsIHIpID0+IHtcbiAgICB0LmZvckVhY2goKHUpID0+IHd0W3VdID0gZSk7XG4gICAgZnVuY3Rpb24gbih1KSB7XG4gICAgICB2YXIgYyA9IHIodSk7XG4gICAgICBjLmxlbmd0aCAhPT0gdC5sZW5ndGggJiYgYnQoXCJNaXNtYXRjaGVkIHR5cGUgY29udmVydGVyIGNvdW50XCIpO1xuICAgICAgZm9yICh2YXIgaCA9IDA7IGggPCB0Lmxlbmd0aDsgKytoKVxuICAgICAgICBqKHRbaF0sIGNbaF0pO1xuICAgIH1cbiAgICB2YXIgYSA9IG5ldyBBcnJheShlLmxlbmd0aCksIGkgPSBbXSwgcyA9IDA7XG4gICAge1xuICAgICAgY29uc3QgdSA9IGU7XG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHUubGVuZ3RoOyArK2MpIHtcbiAgICAgICAgY29uc3QgaCA9IHVbY107XG4gICAgICAgIFouaGFzT3duUHJvcGVydHkoaCkgPyBhW2NdID0gWltoXSA6IChpLnB1c2goaCksIGV0Lmhhc093blByb3BlcnR5KGgpIHx8IChldFtoXSA9IFtdKSwgZXRbaF0ucHVzaCgoKSA9PiB7XG4gICAgICAgICAgYVtjXSA9IFpbaF0sICsrcywgcyA9PT0gaS5sZW5ndGggJiYgbihhKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpLmxlbmd0aCA9PT0gMCAmJiBuKGEpO1xuICB9LCBfciA9ICh0KSA9PiB7XG4gICAgdmFyIGUgPSBndFt0XTtcbiAgICBkZWxldGUgZ3RbdF07XG4gICAgdmFyIHIgPSBlLnJhd0NvbnN0cnVjdG9yLCBuID0gZS5yYXdEZXN0cnVjdG9yLCBhID0gZS5maWVsZHMsIGkgPSBhLm1hcCgocykgPT4gcy5nZXR0ZXJSZXR1cm5UeXBlKS5jb25jYXQoYS5tYXAoKHMpID0+IHMuc2V0dGVyQXJndW1lbnRUeXBlKSk7XG4gICAgUShbdF0sIGksIChzKSA9PiB7XG4gICAgICB2YXIgdSA9IHt9O1xuICAgICAge1xuICAgICAgICBjb25zdCBjID0gYTtcbiAgICAgICAgZm9yIChsZXQgaCA9IDA7IGggPCBjLmxlbmd0aDsgKytoKSB7XG4gICAgICAgICAgY29uc3QgcCA9IGNbaF0sIHkgPSBzW2hdLCBDID0gcC5nZXR0ZXIsIFAgPSBwLmdldHRlckNvbnRleHQsIFMgPSBzW2ggKyBhLmxlbmd0aF0sIHggPSBwLnNldHRlciwgTyA9IHAuc2V0dGVyQ29udGV4dDtcbiAgICAgICAgICB1W3AuZmllbGROYW1lXSA9IHtcbiAgICAgICAgICAgIHJlYWQ6IChFKSA9PiB5LmZyb21XaXJlVHlwZShDKFAsIEUpKSxcbiAgICAgICAgICAgIHdyaXRlOiAoRSwgSykgPT4ge1xuICAgICAgICAgICAgICB2YXIgUiA9IFtdO1xuICAgICAgICAgICAgICB4KE8sIEUsIFMudG9XaXJlVHlwZShSLCBLKSksIEx0KFIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbmFsOiB5Lm9wdGlvbmFsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIG5hbWU6IGUubmFtZSxcbiAgICAgICAgZnJvbVdpcmVUeXBlOiAoYykgPT4ge1xuICAgICAgICAgIHZhciBoID0ge307XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiB1KVxuICAgICAgICAgICAgaFtwXSA9IHVbcF0ucmVhZChjKTtcbiAgICAgICAgICByZXR1cm4gbihjKSwgaDtcbiAgICAgICAgfSxcbiAgICAgICAgdG9XaXJlVHlwZTogKGMsIGgpID0+IHtcbiAgICAgICAgICBmb3IgKHZhciBwIGluIHUpXG4gICAgICAgICAgICBpZiAoIShwIGluIGgpICYmICF1W3BdLm9wdGlvbmFsKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBNaXNzaW5nIGZpZWxkOiBcIiR7cH1cImApO1xuICAgICAgICAgIHZhciB5ID0gcigpO1xuICAgICAgICAgIGZvciAocCBpbiB1KVxuICAgICAgICAgICAgdVtwXS53cml0ZSh5LCBoW3BdKTtcbiAgICAgICAgICByZXR1cm4gYyAhPT0gbnVsbCAmJiBjLnB1c2gobiwgeSksIHk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRWYWx1ZUZyb21Qb2ludGVyOiBpdCxcbiAgICAgICAgZGVzdHJ1Y3RvckZ1bmN0aW9uOiBuXG4gICAgICB9XTtcbiAgICB9KTtcbiAgfSwgeHIgPSAodCwgZSwgciwgbiwgYSkgPT4ge1xuICB9LCBGID0gKHQpID0+IHtcbiAgICBmb3IgKHZhciBlID0gXCJcIjsgOyApIHtcbiAgICAgIHZhciByID0gV1t0KytdO1xuICAgICAgaWYgKCFyKSByZXR1cm4gZTtcbiAgICAgIGUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShyKTtcbiAgICB9XG4gIH0sIHN0ID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IodCkge1xuICAgICAgc3VwZXIodCksIHRoaXMubmFtZSA9IFwiQmluZGluZ0Vycm9yXCI7XG4gICAgfVxuICB9LCAkID0gKHQpID0+IHtcbiAgICB0aHJvdyBuZXcgc3QodCk7XG4gIH07XG4gIGZ1bmN0aW9uIFNyKHQsIGUpIHtcbiAgICBsZXQgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIG4gPSBlLm5hbWU7XG4gICAgaWYgKHQgfHwgJChgdHlwZSBcIiR7bn1cIiBtdXN0IGhhdmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIHR5cGVpZCBwb2ludGVyYCksIFouaGFzT3duUHJvcGVydHkodCkpIHtcbiAgICAgIGlmIChyLmlnbm9yZUR1cGxpY2F0ZVJlZ2lzdHJhdGlvbnMpXG4gICAgICAgIHJldHVybjtcbiAgICAgICQoYENhbm5vdCByZWdpc3RlciB0eXBlICcke259JyB0d2ljZWApO1xuICAgIH1cbiAgICBpZiAoWlt0XSA9IGUsIGRlbGV0ZSB3dFt0XSwgZXQuaGFzT3duUHJvcGVydHkodCkpIHtcbiAgICAgIHZhciBhID0gZXRbdF07XG4gICAgICBkZWxldGUgZXRbdF0sIGEuZm9yRWFjaCgoaSkgPT4gaSgpKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaih0LCBlKSB7XG4gICAgbGV0IHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBTcih0LCBlLCByKTtcbiAgfVxuICB2YXIgSXIgPSAodCwgZSwgciwgbikgPT4ge1xuICAgIGUgPSBGKGUpLCBqKHQsIHtcbiAgICAgIG5hbWU6IGUsXG4gICAgICBmcm9tV2lyZVR5cGU6IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgcmV0dXJuICEhYTtcbiAgICAgIH0sXG4gICAgICB0b1dpcmVUeXBlOiBmdW5jdGlvbihhLCBpKSB7XG4gICAgICAgIHJldHVybiBpID8gciA6IG47XG4gICAgICB9LFxuICAgICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKFdbYV0pO1xuICAgICAgfSxcbiAgICAgIGRlc3RydWN0b3JGdW5jdGlvbjogbnVsbFxuICAgIH0pO1xuICB9LCBEciA9ICh0KSA9PiAoe1xuICAgIGNvdW50OiB0LmNvdW50LFxuICAgIGRlbGV0ZVNjaGVkdWxlZDogdC5kZWxldGVTY2hlZHVsZWQsXG4gICAgcHJlc2VydmVQb2ludGVyT25EZWxldGU6IHQucHJlc2VydmVQb2ludGVyT25EZWxldGUsXG4gICAgcHRyOiB0LnB0cixcbiAgICBwdHJUeXBlOiB0LnB0clR5cGUsXG4gICAgc21hcnRQdHI6IHQuc21hcnRQdHIsXG4gICAgc21hcnRQdHJUeXBlOiB0LnNtYXJ0UHRyVHlwZVxuICB9KSwganQgPSAodCkgPT4ge1xuICAgIGZ1bmN0aW9uIGUocikge1xuICAgICAgcmV0dXJuIHIuJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3MubmFtZTtcbiAgICB9XG4gICAgJChlKHQpICsgXCIgaW5zdGFuY2UgYWxyZWFkeSBkZWxldGVkXCIpO1xuICB9LCBCdCA9ICExLCBpZSA9ICh0KSA9PiB7XG4gIH0sIE1yID0gKHQpID0+IHtcbiAgICB0LnNtYXJ0UHRyID8gdC5zbWFydFB0clR5cGUucmF3RGVzdHJ1Y3Rvcih0LnNtYXJ0UHRyKSA6IHQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3MucmF3RGVzdHJ1Y3Rvcih0LnB0cik7XG4gIH0sIHNlID0gKHQpID0+IHtcbiAgICB0LmNvdW50LnZhbHVlIC09IDE7XG4gICAgdmFyIGUgPSB0LmNvdW50LnZhbHVlID09PSAwO1xuICAgIGUgJiYgTXIodCk7XG4gIH0sIHV0ID0gKHQpID0+IGdsb2JhbFRoaXMuRmluYWxpemF0aW9uUmVnaXN0cnkgPyAoQnQgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKGUpID0+IHtcbiAgICBzZShlLiQkKTtcbiAgfSksIHV0ID0gKGUpID0+IHtcbiAgICB2YXIgciA9IGUuJCQsIG4gPSAhIXIuc21hcnRQdHI7XG4gICAgaWYgKG4pIHtcbiAgICAgIHZhciBhID0ge1xuICAgICAgICAkJDogclxuICAgICAgfTtcbiAgICAgIEJ0LnJlZ2lzdGVyKGUsIGEsIGUpO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSwgaWUgPSAoZSkgPT4gQnQudW5yZWdpc3RlcihlKSwgdXQodCkpIDogKHV0ID0gKGUpID0+IGUsIHQpLCBBciA9ICgpID0+IHtcbiAgICBsZXQgdCA9ICR0LnByb3RvdHlwZTtcbiAgICBPYmplY3QuYXNzaWduKHQsIHtcbiAgICAgIGlzQWxpYXNPZihyKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiAkdCkgfHwgIShyIGluc3RhbmNlb2YgJHQpKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgdmFyIG4gPSB0aGlzLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzLCBhID0gdGhpcy4kJC5wdHI7XG4gICAgICAgIHIuJCQgPSByLiQkO1xuICAgICAgICBmb3IgKHZhciBpID0gci4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzcywgcyA9IHIuJCQucHRyOyBuLmJhc2VDbGFzczsgKVxuICAgICAgICAgIGEgPSBuLnVwY2FzdChhKSwgbiA9IG4uYmFzZUNsYXNzO1xuICAgICAgICBmb3IgKDsgaS5iYXNlQ2xhc3M7IClcbiAgICAgICAgICBzID0gaS51cGNhc3QocyksIGkgPSBpLmJhc2VDbGFzcztcbiAgICAgICAgcmV0dXJuIG4gPT09IGkgJiYgYSA9PT0gcztcbiAgICAgIH0sXG4gICAgICBjbG9uZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuJCQucHRyIHx8IGp0KHRoaXMpLCB0aGlzLiQkLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlKVxuICAgICAgICAgIHJldHVybiB0aGlzLiQkLmNvdW50LnZhbHVlICs9IDEsIHRoaXM7XG4gICAgICAgIHZhciByID0gdXQoT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHtcbiAgICAgICAgICAkJDoge1xuICAgICAgICAgICAgdmFsdWU6IERyKHRoaXMuJCQpXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiByLiQkLmNvdW50LnZhbHVlICs9IDEsIHIuJCQuZGVsZXRlU2NoZWR1bGVkID0gITEsIHI7XG4gICAgICB9LFxuICAgICAgZGVsZXRlKCkge1xuICAgICAgICB0aGlzLiQkLnB0ciB8fCBqdCh0aGlzKSwgdGhpcy4kJC5kZWxldGVTY2hlZHVsZWQgJiYgIXRoaXMuJCQucHJlc2VydmVQb2ludGVyT25EZWxldGUgJiYgJChcIk9iamVjdCBhbHJlYWR5IHNjaGVkdWxlZCBmb3IgZGVsZXRpb25cIiksIGllKHRoaXMpLCBzZSh0aGlzLiQkKSwgdGhpcy4kJC5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSB8fCAodGhpcy4kJC5zbWFydFB0ciA9IHZvaWQgMCwgdGhpcy4kJC5wdHIgPSB2b2lkIDApO1xuICAgICAgfSxcbiAgICAgIGlzRGVsZXRlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLiQkLnB0cjtcbiAgICAgIH0sXG4gICAgICBkZWxldGVMYXRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJCQucHRyIHx8IGp0KHRoaXMpLCB0aGlzLiQkLmRlbGV0ZVNjaGVkdWxlZCAmJiAhdGhpcy4kJC5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSAmJiAkKFwiT2JqZWN0IGFscmVhZHkgc2NoZWR1bGVkIGZvciBkZWxldGlvblwiKSwgdGhpcy4kJC5kZWxldGVTY2hlZHVsZWQgPSAhMCwgdGhpcztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBlID0gU3ltYm9sLmRpc3Bvc2U7XG4gICAgZSAmJiAodFtlXSA9IHQuZGVsZXRlKTtcbiAgfTtcbiAgZnVuY3Rpb24gJHQoKSB7XG4gIH1cbiAgdmFyIFV0ID0gKHQsIGUpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcIm5hbWVcIiwge1xuICAgIHZhbHVlOiB0XG4gIH0pLCB1ZSA9IHt9LCBjZSA9ICh0LCBlLCByKSA9PiB7XG4gICAgaWYgKHRbZV0ub3ZlcmxvYWRUYWJsZSA9PT0gdm9pZCAwKSB7XG4gICAgICB2YXIgbiA9IHRbZV07XG4gICAgICB0W2VdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHMubGVuZ3RoLCBpID0gbmV3IEFycmF5KGEpLCBzID0gMDsgcyA8IGE7IHMrKylcbiAgICAgICAgICBpW3NdID0gYXJndW1lbnRzW3NdO1xuICAgICAgICByZXR1cm4gdFtlXS5vdmVybG9hZFRhYmxlLmhhc093blByb3BlcnR5KGkubGVuZ3RoKSB8fCAkKGBGdW5jdGlvbiAnJHtyfScgY2FsbGVkIHdpdGggYW4gaW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzICgke2kubGVuZ3RofSkgLSBleHBlY3RzIG9uZSBvZiAoJHt0W2VdLm92ZXJsb2FkVGFibGV9KSFgKSwgdFtlXS5vdmVybG9hZFRhYmxlW2kubGVuZ3RoXS5hcHBseSh0aGlzLCBpKTtcbiAgICAgIH0sIHRbZV0ub3ZlcmxvYWRUYWJsZSA9IFtdLCB0W2VdLm92ZXJsb2FkVGFibGVbbi5hcmdDb3VudF0gPSBuO1xuICAgIH1cbiAgfSwgbGUgPSAodCwgZSwgcikgPT4ge1xuICAgIGYuaGFzT3duUHJvcGVydHkodCkgPyAoKHIgPT09IHZvaWQgMCB8fCBmW3RdLm92ZXJsb2FkVGFibGUgIT09IHZvaWQgMCAmJiBmW3RdLm92ZXJsb2FkVGFibGVbcl0gIT09IHZvaWQgMCkgJiYgJChgQ2Fubm90IHJlZ2lzdGVyIHB1YmxpYyBuYW1lICcke3R9JyB0d2ljZWApLCBjZShmLCB0LCB0KSwgZlt0XS5vdmVybG9hZFRhYmxlLmhhc093blByb3BlcnR5KHIpICYmICQoYENhbm5vdCByZWdpc3RlciBtdWx0aXBsZSBvdmVybG9hZHMgb2YgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIG51bWJlciBvZiBhcmd1bWVudHMgKCR7cn0pIWApLCBmW3RdLm92ZXJsb2FkVGFibGVbcl0gPSBlKSA6IChmW3RdID0gZSwgZlt0XS5hcmdDb3VudCA9IHIpO1xuICB9LCBGciA9IDQ4LCBSciA9IDU3LCBMciA9ICh0KSA9PiB7XG4gICAgdCA9IHQucmVwbGFjZSgvW15hLXpBLVowLTlfXS9nLCBcIiRcIik7XG4gICAgdmFyIGUgPSB0LmNoYXJDb2RlQXQoMCk7XG4gICAgcmV0dXJuIGUgPj0gRnIgJiYgZSA8PSBSciA/IGBfJHt0fWAgOiB0O1xuICB9O1xuICBmdW5jdGlvbiBqcih0LCBlLCByLCBuLCBhLCBpLCBzLCB1KSB7XG4gICAgdGhpcy5uYW1lID0gdCwgdGhpcy5jb25zdHJ1Y3RvciA9IGUsIHRoaXMuaW5zdGFuY2VQcm90b3R5cGUgPSByLCB0aGlzLnJhd0Rlc3RydWN0b3IgPSBuLCB0aGlzLmJhc2VDbGFzcyA9IGEsIHRoaXMuZ2V0QWN0dWFsVHlwZSA9IGksIHRoaXMudXBjYXN0ID0gcywgdGhpcy5kb3duY2FzdCA9IHUsIHRoaXMucHVyZVZpcnR1YWxGdW5jdGlvbnMgPSBbXTtcbiAgfVxuICB2YXIgVnQgPSAodCwgZSwgcikgPT4ge1xuICAgIGZvciAoOyBlICE9PSByOyApXG4gICAgICBlLnVwY2FzdCB8fCAkKGBFeHBlY3RlZCBudWxsIG9yIGluc3RhbmNlIG9mICR7ci5uYW1lfSwgZ290IGFuIGluc3RhbmNlIG9mICR7ZS5uYW1lfWApLCB0ID0gZS51cGNhc3QodCksIGUgPSBlLmJhc2VDbGFzcztcbiAgICByZXR1cm4gdDtcbiAgfSwgV3QgPSAodCkgPT4ge1xuICAgIGlmICh0ID09PSBudWxsKVxuICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIHZhciBlID0gdHlwZW9mIHQ7XG4gICAgcmV0dXJuIGUgPT09IFwib2JqZWN0XCIgfHwgZSA9PT0gXCJhcnJheVwiIHx8IGUgPT09IFwiZnVuY3Rpb25cIiA/IHQudG9TdHJpbmcoKSA6IFwiXCIgKyB0O1xuICB9O1xuICBmdW5jdGlvbiBCcih0LCBlKSB7XG4gICAgaWYgKGUgPT09IG51bGwpXG4gICAgICByZXR1cm4gdGhpcy5pc1JlZmVyZW5jZSAmJiAkKGBudWxsIGlzIG5vdCBhIHZhbGlkICR7dGhpcy5uYW1lfWApLCAwO1xuICAgIGUuJCQgfHwgJChgQ2Fubm90IHBhc3MgXCIke1d0KGUpfVwiIGFzIGEgJHt0aGlzLm5hbWV9YCksIGUuJCQucHRyIHx8ICQoYENhbm5vdCBwYXNzIGRlbGV0ZWQgb2JqZWN0IGFzIGEgcG9pbnRlciBvZiB0eXBlICR7dGhpcy5uYW1lfWApO1xuICAgIHZhciByID0gZS4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzcywgbiA9IFZ0KGUuJCQucHRyLCByLCB0aGlzLnJlZ2lzdGVyZWRDbGFzcyk7XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgZnVuY3Rpb24gVXIodCwgZSkge1xuICAgIHZhciByO1xuICAgIGlmIChlID09PSBudWxsKVxuICAgICAgcmV0dXJuIHRoaXMuaXNSZWZlcmVuY2UgJiYgJChgbnVsbCBpcyBub3QgYSB2YWxpZCAke3RoaXMubmFtZX1gKSwgdGhpcy5pc1NtYXJ0UG9pbnRlciA/IChyID0gdGhpcy5yYXdDb25zdHJ1Y3RvcigpLCB0ICE9PSBudWxsICYmIHQucHVzaCh0aGlzLnJhd0Rlc3RydWN0b3IsIHIpLCByKSA6IDA7XG4gICAgKCFlIHx8ICFlLiQkKSAmJiAkKGBDYW5ub3QgcGFzcyBcIiR7V3QoZSl9XCIgYXMgYSAke3RoaXMubmFtZX1gKSwgZS4kJC5wdHIgfHwgJChgQ2Fubm90IHBhc3MgZGVsZXRlZCBvYmplY3QgYXMgYSBwb2ludGVyIG9mIHR5cGUgJHt0aGlzLm5hbWV9YCksICF0aGlzLmlzQ29uc3QgJiYgZS4kJC5wdHJUeXBlLmlzQ29uc3QgJiYgJChgQ2Fubm90IGNvbnZlcnQgYXJndW1lbnQgb2YgdHlwZSAke2UuJCQuc21hcnRQdHJUeXBlID8gZS4kJC5zbWFydFB0clR5cGUubmFtZSA6IGUuJCQucHRyVHlwZS5uYW1lfSB0byBwYXJhbWV0ZXIgdHlwZSAke3RoaXMubmFtZX1gKTtcbiAgICB2YXIgbiA9IGUuJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3M7XG4gICAgaWYgKHIgPSBWdChlLiQkLnB0ciwgbiwgdGhpcy5yZWdpc3RlcmVkQ2xhc3MpLCB0aGlzLmlzU21hcnRQb2ludGVyKVxuICAgICAgc3dpdGNoIChlLiQkLnNtYXJ0UHRyID09PSB2b2lkIDAgJiYgJChcIlBhc3NpbmcgcmF3IHBvaW50ZXIgdG8gc21hcnQgcG9pbnRlciBpcyBpbGxlZ2FsXCIpLCB0aGlzLnNoYXJpbmdQb2xpY3kpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGUuJCQuc21hcnRQdHJUeXBlID09PSB0aGlzID8gciA9IGUuJCQuc21hcnRQdHIgOiAkKGBDYW5ub3QgY29udmVydCBhcmd1bWVudCBvZiB0eXBlICR7ZS4kJC5zbWFydFB0clR5cGUgPyBlLiQkLnNtYXJ0UHRyVHlwZS5uYW1lIDogZS4kJC5wdHJUeXBlLm5hbWV9IHRvIHBhcmFtZXRlciB0eXBlICR7dGhpcy5uYW1lfWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgciA9IGUuJCQuc21hcnRQdHI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBpZiAoZS4kJC5zbWFydFB0clR5cGUgPT09IHRoaXMpXG4gICAgICAgICAgICByID0gZS4kJC5zbWFydFB0cjtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhID0gZS5jbG9uZSgpO1xuICAgICAgICAgICAgciA9IHRoaXMucmF3U2hhcmUociwgQi50b0hhbmRsZSgoKSA9PiBhLmRlbGV0ZSgpKSksIHQgIT09IG51bGwgJiYgdC5wdXNoKHRoaXMucmF3RGVzdHJ1Y3Rvciwgcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICQoXCJVbnN1cHBvcnRpbmcgc2hhcmluZyBwb2xpY3lcIik7XG4gICAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgZnVuY3Rpb24gVnIodCwgZSkge1xuICAgIGlmIChlID09PSBudWxsKVxuICAgICAgcmV0dXJuIHRoaXMuaXNSZWZlcmVuY2UgJiYgJChgbnVsbCBpcyBub3QgYSB2YWxpZCAke3RoaXMubmFtZX1gKSwgMDtcbiAgICBlLiQkIHx8ICQoYENhbm5vdCBwYXNzIFwiJHtXdChlKX1cIiBhcyBhICR7dGhpcy5uYW1lfWApLCBlLiQkLnB0ciB8fCAkKGBDYW5ub3QgcGFzcyBkZWxldGVkIG9iamVjdCBhcyBhIHBvaW50ZXIgb2YgdHlwZSAke3RoaXMubmFtZX1gKSwgZS4kJC5wdHJUeXBlLmlzQ29uc3QgJiYgJChgQ2Fubm90IGNvbnZlcnQgYXJndW1lbnQgb2YgdHlwZSAke2UuJCQucHRyVHlwZS5uYW1lfSB0byBwYXJhbWV0ZXIgdHlwZSAke3RoaXMubmFtZX1gKTtcbiAgICB2YXIgciA9IGUuJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3MsIG4gPSBWdChlLiQkLnB0ciwgciwgdGhpcy5yZWdpc3RlcmVkQ2xhc3MpO1xuICAgIHJldHVybiBuO1xuICB9XG4gIHZhciBmZSA9ICh0LCBlLCByKSA9PiB7XG4gICAgaWYgKGUgPT09IHIpXG4gICAgICByZXR1cm4gdDtcbiAgICBpZiAoci5iYXNlQ2xhc3MgPT09IHZvaWQgMClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciBuID0gZmUodCwgZSwgci5iYXNlQ2xhc3MpO1xuICAgIHJldHVybiBuID09PSBudWxsID8gbnVsbCA6IHIuZG93bmNhc3Qobik7XG4gIH0sIFdyID0ge30sIEhyID0gKHQsIGUpID0+IHtcbiAgICBmb3IgKGUgPT09IHZvaWQgMCAmJiAkKFwicHRyIHNob3VsZCBub3QgYmUgdW5kZWZpbmVkXCIpOyB0LmJhc2VDbGFzczsgKVxuICAgICAgZSA9IHQudXBjYXN0KGUpLCB0ID0gdC5iYXNlQ2xhc3M7XG4gICAgcmV0dXJuIGU7XG4gIH0sIGtyID0gKHQsIGUpID0+IChlID0gSHIodCwgZSksIFdyW2VdKSwgQ3QgPSAodCwgZSkgPT4ge1xuICAgICghZS5wdHJUeXBlIHx8ICFlLnB0cikgJiYgYnQoXCJtYWtlQ2xhc3NIYW5kbGUgcmVxdWlyZXMgcHRyIGFuZCBwdHJUeXBlXCIpO1xuICAgIHZhciByID0gISFlLnNtYXJ0UHRyVHlwZSwgbiA9ICEhZS5zbWFydFB0cjtcbiAgICByZXR1cm4gciAhPT0gbiAmJiBidChcIkJvdGggc21hcnRQdHJUeXBlIGFuZCBzbWFydFB0ciBtdXN0IGJlIHNwZWNpZmllZFwiKSwgZS5jb3VudCA9IHtcbiAgICAgIHZhbHVlOiAxXG4gICAgfSwgdXQoT2JqZWN0LmNyZWF0ZSh0LCB7XG4gICAgICAkJDoge1xuICAgICAgICB2YWx1ZTogZSxcbiAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICB9XG4gICAgfSkpO1xuICB9O1xuICBmdW5jdGlvbiBOcih0KSB7XG4gICAgdmFyIGUgPSB0aGlzLmdldFBvaW50ZWUodCk7XG4gICAgaWYgKCFlKVxuICAgICAgcmV0dXJuIHRoaXMuZGVzdHJ1Y3Rvcih0KSwgbnVsbDtcbiAgICB2YXIgciA9IGtyKHRoaXMucmVnaXN0ZXJlZENsYXNzLCBlKTtcbiAgICBpZiAociAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoci4kJC5jb3VudC52YWx1ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHIuJCQucHRyID0gZSwgci4kJC5zbWFydFB0ciA9IHQsIHIuY2xvbmUoKTtcbiAgICAgIHZhciBuID0gci5jbG9uZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVzdHJ1Y3Rvcih0KSwgbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzU21hcnRQb2ludGVyID8gQ3QodGhpcy5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGUsIHtcbiAgICAgICAgcHRyVHlwZTogdGhpcy5wb2ludGVlVHlwZSxcbiAgICAgICAgcHRyOiBlLFxuICAgICAgICBzbWFydFB0clR5cGU6IHRoaXMsXG4gICAgICAgIHNtYXJ0UHRyOiB0XG4gICAgICB9KSA6IEN0KHRoaXMucmVnaXN0ZXJlZENsYXNzLmluc3RhbmNlUHJvdG90eXBlLCB7XG4gICAgICAgIHB0clR5cGU6IHRoaXMsXG4gICAgICAgIHB0cjogdFxuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5yZWdpc3RlcmVkQ2xhc3MuZ2V0QWN0dWFsVHlwZShlKSwgcyA9IHVlW2ldO1xuICAgIGlmICghcylcbiAgICAgIHJldHVybiBhLmNhbGwodGhpcyk7XG4gICAgdmFyIHU7XG4gICAgdGhpcy5pc0NvbnN0ID8gdSA9IHMuY29uc3RQb2ludGVyVHlwZSA6IHUgPSBzLnBvaW50ZXJUeXBlO1xuICAgIHZhciBjID0gZmUoZSwgdGhpcy5yZWdpc3RlcmVkQ2xhc3MsIHUucmVnaXN0ZXJlZENsYXNzKTtcbiAgICByZXR1cm4gYyA9PT0gbnVsbCA/IGEuY2FsbCh0aGlzKSA6IHRoaXMuaXNTbWFydFBvaW50ZXIgPyBDdCh1LnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSwge1xuICAgICAgcHRyVHlwZTogdSxcbiAgICAgIHB0cjogYyxcbiAgICAgIHNtYXJ0UHRyVHlwZTogdGhpcyxcbiAgICAgIHNtYXJ0UHRyOiB0XG4gICAgfSkgOiBDdCh1LnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSwge1xuICAgICAgcHRyVHlwZTogdSxcbiAgICAgIHB0cjogY1xuICAgIH0pO1xuICB9XG4gIHZhciB6ciA9ICgpID0+IHtcbiAgICBPYmplY3QuYXNzaWduKFR0LnByb3RvdHlwZSwge1xuICAgICAgZ2V0UG9pbnRlZSh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhd0dldFBvaW50ZWUgJiYgKHQgPSB0aGlzLnJhd0dldFBvaW50ZWUodCkpLCB0O1xuICAgICAgfSxcbiAgICAgIGRlc3RydWN0b3IodCkge1xuICAgICAgICB2YXIgZTtcbiAgICAgICAgKGUgPSB0aGlzLnJhd0Rlc3RydWN0b3IpID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCB8fCBlLmNhbGwodGhpcywgdCk7XG4gICAgICB9LFxuICAgICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IGl0LFxuICAgICAgZnJvbVdpcmVUeXBlOiBOclxuICAgIH0pO1xuICB9O1xuICBmdW5jdGlvbiBUdCh0LCBlLCByLCBuLCBhLCBpLCBzLCB1LCBjLCBoLCBwKSB7XG4gICAgdGhpcy5uYW1lID0gdCwgdGhpcy5yZWdpc3RlcmVkQ2xhc3MgPSBlLCB0aGlzLmlzUmVmZXJlbmNlID0gciwgdGhpcy5pc0NvbnN0ID0gbiwgdGhpcy5pc1NtYXJ0UG9pbnRlciA9IGEsIHRoaXMucG9pbnRlZVR5cGUgPSBpLCB0aGlzLnNoYXJpbmdQb2xpY3kgPSBzLCB0aGlzLnJhd0dldFBvaW50ZWUgPSB1LCB0aGlzLnJhd0NvbnN0cnVjdG9yID0gYywgdGhpcy5yYXdTaGFyZSA9IGgsIHRoaXMucmF3RGVzdHJ1Y3RvciA9IHAsICFhICYmIGUuYmFzZUNsYXNzID09PSB2b2lkIDAgPyBuID8gKHRoaXMudG9XaXJlVHlwZSA9IEJyLCB0aGlzLmRlc3RydWN0b3JGdW5jdGlvbiA9IG51bGwpIDogKHRoaXMudG9XaXJlVHlwZSA9IFZyLCB0aGlzLmRlc3RydWN0b3JGdW5jdGlvbiA9IG51bGwpIDogdGhpcy50b1dpcmVUeXBlID0gVXI7XG4gIH1cbiAgdmFyIGhlID0gKHQsIGUsIHIpID0+IHtcbiAgICBmLmhhc093blByb3BlcnR5KHQpIHx8IGJ0KFwiUmVwbGFjaW5nIG5vbmV4aXN0ZW50IHB1YmxpYyBzeW1ib2xcIiksIGZbdF0ub3ZlcmxvYWRUYWJsZSAhPT0gdm9pZCAwICYmIHIgIT09IHZvaWQgMCA/IGZbdF0ub3ZlcmxvYWRUYWJsZVtyXSA9IGUgOiAoZlt0XSA9IGUsIGZbdF0uYXJnQ291bnQgPSByKTtcbiAgfSwgTiA9IHt9LCBHciA9ICh0LCBlLCByKSA9PiB7XG4gICAgdCA9IHQucmVwbGFjZSgvcC9nLCBcImlcIik7XG4gICAgdmFyIG4gPSBOW3RdO1xuICAgIHJldHVybiBuKGUsIC4uLnIpO1xuICB9LCBkZSA9IFtdLCB3ID0gKHQpID0+IHtcbiAgICB2YXIgZSA9IGRlW3RdO1xuICAgIHJldHVybiBlIHx8IChkZVt0XSA9IGUgPSBGZS5nZXQodCkpLCBlO1xuICB9LCBYciA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICBsZXQgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogW107XG4gICAgaWYgKHQuaW5jbHVkZXMoXCJqXCIpKVxuICAgICAgcmV0dXJuIEdyKHQsIGUsIHIpO1xuICAgIHZhciBuID0gdyhlKSwgYSA9IG4oLi4ucik7XG4gICAgcmV0dXJuIGE7XG4gIH0sIHFyID0gZnVuY3Rpb24odCwgZSkge1xuICAgIGxldCByID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiAhMTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCwgYSA9IG5ldyBBcnJheShuKSwgaSA9IDA7IGkgPCBuOyBpKyspXG4gICAgICAgIGFbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICByZXR1cm4gWHIodCwgZSwgYSwgcik7XG4gICAgfTtcbiAgfSwgTCA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICB0ID0gRih0KTtcbiAgICBmdW5jdGlvbiByKCkge1xuICAgICAgaWYgKHQuaW5jbHVkZXMoXCJqXCIpKVxuICAgICAgICByZXR1cm4gcXIodCwgZSk7XG4gICAgICB2YXIgYSA9IHcoZSk7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgdmFyIG4gPSByKCk7XG4gICAgcmV0dXJuIHR5cGVvZiBuICE9IFwiZnVuY3Rpb25cIiAmJiAkKGB1bmtub3duIGZ1bmN0aW9uIHBvaW50ZXIgd2l0aCBzaWduYXR1cmUgJHt0fTogJHtlfWApLCBuO1xuICB9O1xuICBjbGFzcyBZciBleHRlbmRzIEVycm9yIHtcbiAgfVxuICB2YXIgcGUgPSAodCkgPT4ge1xuICAgIHZhciBlID0gRWUodCksIHIgPSBGKGUpO1xuICAgIHJldHVybiB6KGUpLCByO1xuICB9LCBFdCA9ICh0LCBlKSA9PiB7XG4gICAgdmFyIHIgPSBbXSwgbiA9IHt9O1xuICAgIGZ1bmN0aW9uIGEoaSkge1xuICAgICAgaWYgKCFuW2ldICYmICFaW2ldKSB7XG4gICAgICAgIGlmICh3dFtpXSkge1xuICAgICAgICAgIHd0W2ldLmZvckVhY2goYSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHIucHVzaChpKSwgbltpXSA9ICEwO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBlLmZvckVhY2goYSksIG5ldyBZcihgJHt0fTogYCArIHIubWFwKHBlKS5qb2luKFtcIiwgXCJdKSk7XG4gIH0sIFpyID0gKHQsIGUsIHIsIG4sIGEsIGksIHMsIHUsIGMsIGgsIHAsIHksIEMpID0+IHtcbiAgICBwID0gRihwKSwgaSA9IEwoYSwgaSksIHUgJiYgKHUgPSBMKHMsIHUpKSwgaCAmJiAoaCA9IEwoYywgaCkpLCBDID0gTCh5LCBDKTtcbiAgICB2YXIgUCA9IExyKHApO1xuICAgIGxlKFAsIGZ1bmN0aW9uKCkge1xuICAgICAgRXQoYENhbm5vdCBjb25zdHJ1Y3QgJHtwfSBkdWUgdG8gdW5ib3VuZCB0eXBlc2AsIFtuXSk7XG4gICAgfSksIFEoW3QsIGUsIHJdLCBuID8gW25dIDogW10sIChTKSA9PiB7XG4gICAgICBTID0gU1swXTtcbiAgICAgIHZhciB4LCBPO1xuICAgICAgbiA/ICh4ID0gUy5yZWdpc3RlcmVkQ2xhc3MsIE8gPSB4Lmluc3RhbmNlUHJvdG90eXBlKSA6IE8gPSAkdC5wcm90b3R5cGU7XG4gICAgICB2YXIgRSA9IFV0KHAsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpICE9PSBLKVxuICAgICAgICAgIHRocm93IG5ldyBzdChgVXNlICduZXcnIHRvIGNvbnN0cnVjdCAke3B9YCk7XG4gICAgICAgIGlmIChSLmNvbnN0cnVjdG9yX2JvZHkgPT09IHZvaWQgMClcbiAgICAgICAgICB0aHJvdyBuZXcgc3QoYCR7cH0gaGFzIG5vIGFjY2Vzc2libGUgY29uc3RydWN0b3JgKTtcbiAgICAgICAgZm9yICh2YXIgamUgPSBhcmd1bWVudHMubGVuZ3RoLCBfdCA9IG5ldyBBcnJheShqZSksIHh0ID0gMDsgeHQgPCBqZTsgeHQrKylcbiAgICAgICAgICBfdFt4dF0gPSBhcmd1bWVudHNbeHRdO1xuICAgICAgICB2YXIgQmUgPSBSLmNvbnN0cnVjdG9yX2JvZHlbX3QubGVuZ3RoXTtcbiAgICAgICAgaWYgKEJlID09PSB2b2lkIDApXG4gICAgICAgICAgdGhyb3cgbmV3IHN0KGBUcmllZCB0byBpbnZva2UgY3RvciBvZiAke3B9IHdpdGggaW52YWxpZCBudW1iZXIgb2YgcGFyYW1ldGVycyAoJHtfdC5sZW5ndGh9KSAtIGV4cGVjdGVkICgke09iamVjdC5rZXlzKFIuY29uc3RydWN0b3JfYm9keSkudG9TdHJpbmcoKX0pIHBhcmFtZXRlcnMgaW5zdGVhZCFgKTtcbiAgICAgICAgcmV0dXJuIEJlLmFwcGx5KHRoaXMsIF90KTtcbiAgICAgIH0pLCBLID0gT2JqZWN0LmNyZWF0ZShPLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IEVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBFLnByb3RvdHlwZSA9IEs7XG4gICAgICB2YXIgUiA9IG5ldyBqcihwLCBFLCBLLCBDLCB4LCBpLCB1LCBoKTtcbiAgICAgIGlmIChSLmJhc2VDbGFzcykge1xuICAgICAgICB2YXIgaywgT3Q7XG4gICAgICAgIChPdCA9IChrID0gUi5iYXNlQ2xhc3MpLl9fZGVyaXZlZENsYXNzZXMpICE9PSBudWxsICYmIE90ICE9PSB2b2lkIDAgfHwgKGsuX19kZXJpdmVkQ2xhc3NlcyA9IFtdKSwgUi5iYXNlQ2xhc3MuX19kZXJpdmVkQ2xhc3Nlcy5wdXNoKFIpO1xuICAgICAgfVxuICAgICAgdmFyIERhID0gbmV3IFR0KHAsIFIsICEwLCAhMSwgITEpLCBSZSA9IG5ldyBUdChwICsgXCIqXCIsIFIsICExLCAhMSwgITEpLCBMZSA9IG5ldyBUdChwICsgXCIgY29uc3QqXCIsIFIsICExLCAhMCwgITEpO1xuICAgICAgcmV0dXJuIHVlW3RdID0ge1xuICAgICAgICBwb2ludGVyVHlwZTogUmUsXG4gICAgICAgIGNvbnN0UG9pbnRlclR5cGU6IExlXG4gICAgICB9LCBoZShQLCBFKSwgW0RhLCBSZSwgTGVdO1xuICAgIH0pO1xuICB9LCBIdCA9ICh0LCBlKSA9PiB7XG4gICAgZm9yICh2YXIgciA9IFtdLCBuID0gMDsgbiA8IHQ7IG4rKylcbiAgICAgIHIucHVzaChUW2UgKyBuICogNCA+PiAyXSk7XG4gICAgcmV0dXJuIHI7XG4gIH07XG4gIGZ1bmN0aW9uIFFyKHQpIHtcbiAgICBmb3IgKHZhciBlID0gMTsgZSA8IHQubGVuZ3RoOyArK2UpXG4gICAgICBpZiAodFtlXSAhPT0gbnVsbCAmJiB0W2VdLmRlc3RydWN0b3JGdW5jdGlvbiA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGZ1bmN0aW9uIGt0KHQsIGUsIHIsIG4sIGEsIGkpIHtcbiAgICB2YXIgcyA9IGUubGVuZ3RoO1xuICAgIHMgPCAyICYmICQoXCJhcmdUeXBlcyBhcnJheSBzaXplIG1pc21hdGNoISBNdXN0IGF0IGxlYXN0IGdldCByZXR1cm4gdmFsdWUgYW5kICd0aGlzJyB0eXBlcyFcIik7XG4gICAgdmFyIHUgPSBlWzFdICE9PSBudWxsICYmIHIgIT09IG51bGwsIGMgPSBRcihlKSwgaCA9ICFlWzBdLmlzVm9pZCwgcCA9IHMgLSAyLCB5ID0gbmV3IEFycmF5KHApLCBDID0gW10sIFAgPSBbXSwgUyA9IGZ1bmN0aW9uKCkge1xuICAgICAgUC5sZW5ndGggPSAwO1xuICAgICAgdmFyIHg7XG4gICAgICBDLmxlbmd0aCA9IHUgPyAyIDogMSwgQ1swXSA9IGEsIHUgJiYgKHggPSBlWzFdLnRvV2lyZVR5cGUoUCwgdGhpcyksIENbMV0gPSB4KTtcbiAgICAgIGZvciAodmFyIE8gPSAwOyBPIDwgcDsgKytPKVxuICAgICAgICB5W09dID0gZVtPICsgMl0udG9XaXJlVHlwZShQLCBPIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IE8gPyB2b2lkIDAgOiBhcmd1bWVudHNbT10pLCBDLnB1c2goeVtPXSk7XG4gICAgICB2YXIgRSA9IG4oLi4uQyk7XG4gICAgICBmdW5jdGlvbiBLKFIpIHtcbiAgICAgICAgaWYgKGMpXG4gICAgICAgICAgTHQoUCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKHZhciBrID0gdSA/IDEgOiAyOyBrIDwgZS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdmFyIE90ID0gayA9PT0gMSA/IHggOiB5W2sgLSAyXTtcbiAgICAgICAgICAgIGVba10uZGVzdHJ1Y3RvckZ1bmN0aW9uICE9PSBudWxsICYmIGVba10uZGVzdHJ1Y3RvckZ1bmN0aW9uKE90KTtcbiAgICAgICAgICB9XG4gICAgICAgIGlmIChoKVxuICAgICAgICAgIHJldHVybiBlWzBdLmZyb21XaXJlVHlwZShSKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBLKEUpO1xuICAgIH07XG4gICAgcmV0dXJuIFV0KHQsIFMpO1xuICB9XG4gIHZhciBKciA9ICh0LCBlLCByLCBuLCBhLCBpKSA9PiB7XG4gICAgdmFyIHMgPSBIdChlLCByKTtcbiAgICBhID0gTChuLCBhKSwgUShbXSwgW3RdLCAodSkgPT4ge1xuICAgICAgdSA9IHVbMF07XG4gICAgICB2YXIgYyA9IGBjb25zdHJ1Y3RvciAke3UubmFtZX1gO1xuICAgICAgaWYgKHUucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHkgPT09IHZvaWQgMCAmJiAodS5yZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3JfYm9keSA9IFtdKSwgdS5yZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3JfYm9keVtlIC0gMV0gIT09IHZvaWQgMClcbiAgICAgICAgdGhyb3cgbmV3IHN0KGBDYW5ub3QgcmVnaXN0ZXIgbXVsdGlwbGUgY29uc3RydWN0b3JzIHdpdGggaWRlbnRpY2FsIG51bWJlciBvZiBwYXJhbWV0ZXJzICgke2UgLSAxfSkgZm9yIGNsYXNzICcke3UubmFtZX0nISBPdmVybG9hZCByZXNvbHV0aW9uIGlzIGN1cnJlbnRseSBvbmx5IHBlcmZvcm1lZCB1c2luZyB0aGUgcGFyYW1ldGVyIGNvdW50LCBub3QgYWN0dWFsIHR5cGUgaW5mbyFgKTtcbiAgICAgIHJldHVybiB1LnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5W2UgLSAxXSA9ICgpID0+IHtcbiAgICAgICAgRXQoYENhbm5vdCBjb25zdHJ1Y3QgJHt1Lm5hbWV9IGR1ZSB0byB1bmJvdW5kIHR5cGVzYCwgcyk7XG4gICAgICB9LCBRKFtdLCBzLCAoaCkgPT4gKGguc3BsaWNlKDEsIDAsIG51bGwpLCB1LnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5W2UgLSAxXSA9IGt0KGMsIGgsIG51bGwsIGEsIGkpLCBbXSkpLCBbXTtcbiAgICB9KTtcbiAgfSwgeWUgPSAodCkgPT4ge1xuICAgIHQgPSB0LnRyaW0oKTtcbiAgICBjb25zdCBlID0gdC5pbmRleE9mKFwiKFwiKTtcbiAgICByZXR1cm4gZSA9PT0gLTEgPyB0IDogdC5zbGljZSgwLCBlKTtcbiAgfSwgS3IgPSAodCwgZSwgciwgbiwgYSwgaSwgcywgdSwgYywgaCkgPT4ge1xuICAgIHZhciBwID0gSHQociwgbik7XG4gICAgZSA9IEYoZSksIGUgPSB5ZShlKSwgaSA9IEwoYSwgaSksIFEoW10sIFt0XSwgKHkpID0+IHtcbiAgICAgIHkgPSB5WzBdO1xuICAgICAgdmFyIEMgPSBgJHt5Lm5hbWV9LiR7ZX1gO1xuICAgICAgZS5zdGFydHNXaXRoKFwiQEBcIikgJiYgKGUgPSBTeW1ib2xbZS5zdWJzdHJpbmcoMildKSwgdSAmJiB5LnJlZ2lzdGVyZWRDbGFzcy5wdXJlVmlydHVhbEZ1bmN0aW9ucy5wdXNoKGUpO1xuICAgICAgZnVuY3Rpb24gUCgpIHtcbiAgICAgICAgRXQoYENhbm5vdCBjYWxsICR7Q30gZHVlIHRvIHVuYm91bmQgdHlwZXNgLCBwKTtcbiAgICAgIH1cbiAgICAgIHZhciBTID0geS5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGUsIHggPSBTW2VdO1xuICAgICAgcmV0dXJuIHggPT09IHZvaWQgMCB8fCB4Lm92ZXJsb2FkVGFibGUgPT09IHZvaWQgMCAmJiB4LmNsYXNzTmFtZSAhPT0geS5uYW1lICYmIHguYXJnQ291bnQgPT09IHIgLSAyID8gKFAuYXJnQ291bnQgPSByIC0gMiwgUC5jbGFzc05hbWUgPSB5Lm5hbWUsIFNbZV0gPSBQKSA6IChjZShTLCBlLCBDKSwgU1tlXS5vdmVybG9hZFRhYmxlW3IgLSAyXSA9IFApLCBRKFtdLCBwLCAoTykgPT4ge1xuICAgICAgICB2YXIgRSA9IGt0KEMsIE8sIHksIGksIHMpO1xuICAgICAgICByZXR1cm4gU1tlXS5vdmVybG9hZFRhYmxlID09PSB2b2lkIDAgPyAoRS5hcmdDb3VudCA9IHIgLSAyLCBTW2VdID0gRSkgOiBTW2VdLm92ZXJsb2FkVGFibGVbciAtIDJdID0gRSwgW107XG4gICAgICB9KSwgW107XG4gICAgfSk7XG4gIH0sIHZlID0gW10sIEogPSBbMCwgMSwgLCAxLCBudWxsLCAxLCAhMCwgMSwgITEsIDFdLCBOdCA9ICh0KSA9PiB7XG4gICAgdCA+IDkgJiYgLS1KW3QgKyAxXSA9PT0gMCAmJiAoSlt0XSA9IHZvaWQgMCwgdmUucHVzaCh0KSk7XG4gIH0sIEIgPSB7XG4gICAgdG9WYWx1ZTogKHQpID0+ICh0IHx8ICQoYENhbm5vdCB1c2UgZGVsZXRlZCB2YWwuIGhhbmRsZSA9ICR7dH1gKSwgSlt0XSksXG4gICAgdG9IYW5kbGU6ICh0KSA9PiB7XG4gICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgY2FzZSB2b2lkIDA6XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgY2FzZSAhMDpcbiAgICAgICAgICByZXR1cm4gNjtcbiAgICAgICAgY2FzZSAhMTpcbiAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IGUgPSB2ZS5wb3AoKSB8fCBKLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gSltlXSA9IHQsIEpbZSArIDFdID0gMSwgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgbWUgPSB7XG4gICAgbmFtZTogXCJlbXNjcmlwdGVuOjp2YWxcIixcbiAgICBmcm9tV2lyZVR5cGU6ICh0KSA9PiB7XG4gICAgICB2YXIgZSA9IEIudG9WYWx1ZSh0KTtcbiAgICAgIHJldHVybiBOdCh0KSwgZTtcbiAgICB9LFxuICAgIHRvV2lyZVR5cGU6ICh0LCBlKSA9PiBCLnRvSGFuZGxlKGUpLFxuICAgIHJlYWRWYWx1ZUZyb21Qb2ludGVyOiBpdCxcbiAgICBkZXN0cnVjdG9yRnVuY3Rpb246IG51bGxcbiAgfSwgdG4gPSAodCkgPT4gaih0LCBtZSksIGVuID0gKHQsIGUpID0+IHtcbiAgICBzd2l0Y2ggKGUpIHtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoS3RbciA+PiAyXSk7XG4gICAgICAgIH07XG4gICAgICBjYXNlIDg6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKHRlW3IgPj4gM10pO1xuICAgICAgICB9O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBmbG9hdCB3aWR0aCAoJHtlfSk6ICR7dH1gKTtcbiAgICB9XG4gIH0sIHJuID0gKHQsIGUsIHIpID0+IHtcbiAgICBlID0gRihlKSwgaih0LCB7XG4gICAgICBuYW1lOiBlLFxuICAgICAgZnJvbVdpcmVUeXBlOiAobikgPT4gbixcbiAgICAgIHRvV2lyZVR5cGU6IChuLCBhKSA9PiBhLFxuICAgICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IGVuKGUsIHIpLFxuICAgICAgZGVzdHJ1Y3RvckZ1bmN0aW9uOiBudWxsXG4gICAgfSk7XG4gIH0sIG5uID0gKHQsIGUsIHIsIG4sIGEsIGksIHMsIHUpID0+IHtcbiAgICB2YXIgYyA9IEh0KGUsIHIpO1xuICAgIHQgPSBGKHQpLCB0ID0geWUodCksIGEgPSBMKG4sIGEpLCBsZSh0LCBmdW5jdGlvbigpIHtcbiAgICAgIEV0KGBDYW5ub3QgY2FsbCAke3R9IGR1ZSB0byB1bmJvdW5kIHR5cGVzYCwgYyk7XG4gICAgfSwgZSAtIDEpLCBRKFtdLCBjLCAoaCkgPT4ge1xuICAgICAgdmFyIHAgPSBbaFswXSwgbnVsbF0uY29uY2F0KGguc2xpY2UoMSkpO1xuICAgICAgcmV0dXJuIGhlKHQsIGt0KHQsIHAsIG51bGwsIGEsIGkpLCBlIC0gMSksIFtdO1xuICAgIH0pO1xuICB9LCBhbiA9ICh0LCBlLCByKSA9PiB7XG4gICAgc3dpdGNoIChlKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiByID8gKG4pID0+IFlbbl0gOiAobikgPT4gV1tuXTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIHIgPyAobikgPT4gZHRbbiA+PiAxXSA6IChuKSA9PiBhdFtuID4+IDFdO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gciA/IChuKSA9PiBvdFtuID4+IDJdIDogKG4pID0+IFRbbiA+PiAyXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgaW50ZWdlciB3aWR0aCAoJHtlfSk6ICR7dH1gKTtcbiAgICB9XG4gIH0sIG9uID0gKHQsIGUsIHIsIG4sIGEpID0+IHtcbiAgICBlID0gRihlKTtcbiAgICBjb25zdCBpID0gbiA9PT0gMDtcbiAgICBsZXQgcyA9IChjKSA9PiBjO1xuICAgIGlmIChpKSB7XG4gICAgICB2YXIgdSA9IDMyIC0gOCAqIHI7XG4gICAgICBzID0gKGMpID0+IGMgPDwgdSA+Pj4gdSwgYSA9IHMoYSk7XG4gICAgfVxuICAgIGoodCwge1xuICAgICAgbmFtZTogZSxcbiAgICAgIGZyb21XaXJlVHlwZTogcyxcbiAgICAgIHRvV2lyZVR5cGU6IChjLCBoKSA9PiBoLFxuICAgICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IGFuKGUsIHIsIG4gIT09IDApLFxuICAgICAgZGVzdHJ1Y3RvckZ1bmN0aW9uOiBudWxsXG4gICAgfSk7XG4gIH0sIHNuID0gKHQsIGUsIHIpID0+IHtcbiAgICB2YXIgbiA9IFtJbnQ4QXJyYXksIFVpbnQ4QXJyYXksIEludDE2QXJyYXksIFVpbnQxNkFycmF5LCBJbnQzMkFycmF5LCBVaW50MzJBcnJheSwgRmxvYXQzMkFycmF5LCBGbG9hdDY0QXJyYXldLCBhID0gbltlXTtcbiAgICBmdW5jdGlvbiBpKHMpIHtcbiAgICAgIHZhciB1ID0gVFtzID4+IDJdLCBjID0gVFtzICsgNCA+PiAyXTtcbiAgICAgIHJldHVybiBuZXcgYShZLmJ1ZmZlciwgYywgdSk7XG4gICAgfVxuICAgIHIgPSBGKHIpLCBqKHQsIHtcbiAgICAgIG5hbWU6IHIsXG4gICAgICBmcm9tV2lyZVR5cGU6IGksXG4gICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogaVxuICAgIH0sIHtcbiAgICAgIGlnbm9yZUR1cGxpY2F0ZVJlZ2lzdHJhdGlvbnM6ICEwXG4gICAgfSk7XG4gIH0sIHVuID0gT2JqZWN0LmFzc2lnbih7XG4gICAgb3B0aW9uYWw6ICEwXG4gIH0sIG1lKSwgY24gPSAodCwgZSkgPT4ge1xuICAgIGoodCwgdW4pO1xuICB9LCBsbiA9ICh0LCBlLCByLCBuKSA9PiB7XG4gICAgaWYgKCEobiA+IDApKSByZXR1cm4gMDtcbiAgICBmb3IgKHZhciBhID0gciwgaSA9IHIgKyBuIC0gMSwgcyA9IDA7IHMgPCB0Lmxlbmd0aDsgKytzKSB7XG4gICAgICB2YXIgdSA9IHQuY29kZVBvaW50QXQocyk7XG4gICAgICBpZiAodSA8PSAxMjcpIHtcbiAgICAgICAgaWYgKHIgPj0gaSkgYnJlYWs7XG4gICAgICAgIGVbcisrXSA9IHU7XG4gICAgICB9IGVsc2UgaWYgKHUgPD0gMjA0Nykge1xuICAgICAgICBpZiAociArIDEgPj0gaSkgYnJlYWs7XG4gICAgICAgIGVbcisrXSA9IDE5MiB8IHUgPj4gNiwgZVtyKytdID0gMTI4IHwgdSAmIDYzO1xuICAgICAgfSBlbHNlIGlmICh1IDw9IDY1NTM1KSB7XG4gICAgICAgIGlmIChyICsgMiA+PSBpKSBicmVhaztcbiAgICAgICAgZVtyKytdID0gMjI0IHwgdSA+PiAxMiwgZVtyKytdID0gMTI4IHwgdSA+PiA2ICYgNjMsIGVbcisrXSA9IDEyOCB8IHUgJiA2MztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyICsgMyA+PSBpKSBicmVhaztcbiAgICAgICAgZVtyKytdID0gMjQwIHwgdSA+PiAxOCwgZVtyKytdID0gMTI4IHwgdSA+PiAxMiAmIDYzLCBlW3IrK10gPSAxMjggfCB1ID4+IDYgJiA2MywgZVtyKytdID0gMTI4IHwgdSAmIDYzLCBzKys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlW3JdID0gMCwgciAtIGE7XG4gIH0sIHJ0ID0gKHQsIGUsIHIpID0+IGxuKHQsIFcsIGUsIHIpLCBnZSA9ICh0KSA9PiB7XG4gICAgZm9yICh2YXIgZSA9IDAsIHIgPSAwOyByIDwgdC5sZW5ndGg7ICsrcikge1xuICAgICAgdmFyIG4gPSB0LmNoYXJDb2RlQXQocik7XG4gICAgICBuIDw9IDEyNyA/IGUrKyA6IG4gPD0gMjA0NyA/IGUgKz0gMiA6IG4gPj0gNTUyOTYgJiYgbiA8PSA1NzM0MyA/IChlICs9IDQsICsrcikgOiBlICs9IDM7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCB3ZSA9IGdsb2JhbFRoaXMuVGV4dERlY29kZXIgJiYgbmV3IFRleHREZWNvZGVyKCksIGJlID0gKHQsIGUsIHIsIG4pID0+IHtcbiAgICB2YXIgYSA9IGUgKyByO1xuICAgIGlmIChuKSByZXR1cm4gYTtcbiAgICBmb3IgKDsgdFtlXSAmJiAhKGUgPj0gYSk7ICkgKytlO1xuICAgIHJldHVybiBlO1xuICB9LCAkZSA9IGZ1bmN0aW9uKHQpIHtcbiAgICBsZXQgZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogMCwgciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdm9pZCAwLCBuID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB2b2lkIDA7XG4gICAgdmFyIGEgPSBiZSh0LCBlLCByLCBuKTtcbiAgICBpZiAoYSAtIGUgPiAxNiAmJiB0LmJ1ZmZlciAmJiB3ZSlcbiAgICAgIHJldHVybiB3ZS5kZWNvZGUodC5zdWJhcnJheShlLCBhKSk7XG4gICAgZm9yICh2YXIgaSA9IFwiXCI7IGUgPCBhOyApIHtcbiAgICAgIHZhciBzID0gdFtlKytdO1xuICAgICAgaWYgKCEocyAmIDEyOCkpIHtcbiAgICAgICAgaSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHMpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciB1ID0gdFtlKytdICYgNjM7XG4gICAgICBpZiAoKHMgJiAyMjQpID09IDE5Mikge1xuICAgICAgICBpICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKHMgJiAzMSkgPDwgNiB8IHUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBjID0gdFtlKytdICYgNjM7XG4gICAgICBpZiAoKHMgJiAyNDApID09IDIyNCA/IHMgPSAocyAmIDE1KSA8PCAxMiB8IHUgPDwgNiB8IGMgOiBzID0gKHMgJiA3KSA8PCAxOCB8IHUgPDwgMTIgfCBjIDw8IDYgfCB0W2UrK10gJiA2MywgcyA8IDY1NTM2KVxuICAgICAgICBpICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocyk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGggPSBzIC0gNjU1MzY7XG4gICAgICAgIGkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NiB8IGggPj4gMTAsIDU2MzIwIHwgaCAmIDEwMjMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfSwgZm4gPSAodCwgZSwgcikgPT4gdCA/ICRlKFcsIHQsIGUsIHIpIDogXCJcIiwgaG4gPSAodCwgZSkgPT4ge1xuICAgIGUgPSBGKGUpLCBqKHQsIHtcbiAgICAgIG5hbWU6IGUsXG4gICAgICBmcm9tV2lyZVR5cGUocikge1xuICAgICAgICB2YXIgbiA9IFRbciA+PiAyXSwgYSA9IHIgKyA0LCBpO1xuICAgICAgICByZXR1cm4gaSA9IGZuKGEsIG4sICEwKSwgeihyKSwgaTtcbiAgICAgIH0sXG4gICAgICB0b1dpcmVUeXBlKHIsIG4pIHtcbiAgICAgICAgbiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyICYmIChuID0gbmV3IFVpbnQ4QXJyYXkobikpO1xuICAgICAgICB2YXIgYSwgaSA9IHR5cGVvZiBuID09IFwic3RyaW5nXCI7XG4gICAgICAgIGkgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KG4pICYmIG4uQllURVNfUEVSX0VMRU1FTlQgPT0gMSB8fCAkKFwiQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBzdGQ6OnN0cmluZ1wiKSwgaSA/IGEgPSBnZShuKSA6IGEgPSBuLmxlbmd0aDtcbiAgICAgICAgdmFyIHMgPSBYdCg0ICsgYSArIDEpLCB1ID0gcyArIDQ7XG4gICAgICAgIHJldHVybiBUW3MgPj4gMl0gPSBhLCBpID8gcnQobiwgdSwgYSArIDEpIDogVy5zZXQobiwgdSksIHIgIT09IG51bGwgJiYgci5wdXNoKHosIHMpLCBzO1xuICAgICAgfSxcbiAgICAgIHJlYWRWYWx1ZUZyb21Qb2ludGVyOiBpdCxcbiAgICAgIGRlc3RydWN0b3JGdW5jdGlvbihyKSB7XG4gICAgICAgIHoocik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIENlID0gZ2xvYmFsVGhpcy5UZXh0RGVjb2RlciA/IG5ldyBUZXh0RGVjb2RlcihcInV0Zi0xNmxlXCIpIDogdm9pZCAwLCBkbiA9ICh0LCBlLCByKSA9PiB7XG4gICAgdmFyIG4gPSB0ID4+IDEsIGEgPSBiZShhdCwgbiwgZSAvIDIsIHIpO1xuICAgIGlmIChhIC0gbiA+IDE2ICYmIENlKSByZXR1cm4gQ2UuZGVjb2RlKGF0LnN1YmFycmF5KG4sIGEpKTtcbiAgICBmb3IgKHZhciBpID0gXCJcIiwgcyA9IG47IHMgPCBhOyArK3MpIHtcbiAgICAgIHZhciB1ID0gYXRbc107XG4gICAgICBpICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodSk7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9LCBwbiA9ICh0LCBlLCByKSA9PiB7XG4gICAgaWYgKHIgIT0gbnVsbCB8fCAociA9IDIxNDc0ODM2NDcpLCByIDwgMikgcmV0dXJuIDA7XG4gICAgciAtPSAyO1xuICAgIGZvciAodmFyIG4gPSBlLCBhID0gciA8IHQubGVuZ3RoICogMiA/IHIgLyAyIDogdC5sZW5ndGgsIGkgPSAwOyBpIDwgYTsgKytpKSB7XG4gICAgICB2YXIgcyA9IHQuY2hhckNvZGVBdChpKTtcbiAgICAgIGR0W2UgPj4gMV0gPSBzLCBlICs9IDI7XG4gICAgfVxuICAgIHJldHVybiBkdFtlID4+IDFdID0gMCwgZSAtIG47XG4gIH0sIHluID0gKHQpID0+IHQubGVuZ3RoICogMiwgdm4gPSAodCwgZSwgcikgPT4ge1xuICAgIGZvciAodmFyIG4gPSBcIlwiLCBhID0gdCA+PiAyLCBpID0gMDsgIShpID49IGUgLyA0KTsgaSsrKSB7XG4gICAgICB2YXIgcyA9IFRbYSArIGldO1xuICAgICAgaWYgKCFzICYmICFyKSBicmVhaztcbiAgICAgIG4gKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQocyk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9LCBtbiA9ICh0LCBlLCByKSA9PiB7XG4gICAgaWYgKHIgIT0gbnVsbCB8fCAociA9IDIxNDc0ODM2NDcpLCByIDwgNCkgcmV0dXJuIDA7XG4gICAgZm9yICh2YXIgbiA9IGUsIGEgPSBuICsgciAtIDQsIGkgPSAwOyBpIDwgdC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHMgPSB0LmNvZGVQb2ludEF0KGkpO1xuICAgICAgaWYgKHMgPiA2NTUzNSAmJiBpKyssIG90W2UgPj4gMl0gPSBzLCBlICs9IDQsIGUgKyA0ID4gYSkgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvdFtlID4+IDJdID0gMCwgZSAtIG47XG4gIH0sIGduID0gKHQpID0+IHtcbiAgICBmb3IgKHZhciBlID0gMCwgciA9IDA7IHIgPCB0Lmxlbmd0aDsgKytyKSB7XG4gICAgICB2YXIgbiA9IHQuY29kZVBvaW50QXQocik7XG4gICAgICBuID4gNjU1MzUgJiYgcisrLCBlICs9IDQ7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCB3biA9ICh0LCBlLCByKSA9PiB7XG4gICAgciA9IEYocik7XG4gICAgdmFyIG4sIGEsIGk7XG4gICAgZSA9PT0gMiA/IChuID0gZG4sIGEgPSBwbiwgaSA9IHluKSA6IChuID0gdm4sIGEgPSBtbiwgaSA9IGduKSwgaih0LCB7XG4gICAgICBuYW1lOiByLFxuICAgICAgZnJvbVdpcmVUeXBlOiAocykgPT4ge1xuICAgICAgICB2YXIgdSA9IFRbcyA+PiAyXSwgYyA9IG4ocyArIDQsIHUgKiBlLCAhMCk7XG4gICAgICAgIHJldHVybiB6KHMpLCBjO1xuICAgICAgfSxcbiAgICAgIHRvV2lyZVR5cGU6IChzLCB1KSA9PiB7XG4gICAgICAgIHR5cGVvZiB1ICE9IFwic3RyaW5nXCIgJiYgJChgQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBDKysgc3RyaW5nIHR5cGUgJHtyfWApO1xuICAgICAgICB2YXIgYyA9IGkodSksIGggPSBYdCg0ICsgYyArIGUpO1xuICAgICAgICByZXR1cm4gVFtoID4+IDJdID0gYyAvIGUsIGEodSwgaCArIDQsIGMgKyBlKSwgcyAhPT0gbnVsbCAmJiBzLnB1c2goeiwgaCksIGg7XG4gICAgICB9LFxuICAgICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IGl0LFxuICAgICAgZGVzdHJ1Y3RvckZ1bmN0aW9uKHMpIHtcbiAgICAgICAgeihzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgYm4gPSAodCwgZSwgciwgbiwgYSwgaSkgPT4ge1xuICAgIGd0W3RdID0ge1xuICAgICAgbmFtZTogRihlKSxcbiAgICAgIHJhd0NvbnN0cnVjdG9yOiBMKHIsIG4pLFxuICAgICAgcmF3RGVzdHJ1Y3RvcjogTChhLCBpKSxcbiAgICAgIGZpZWxkczogW11cbiAgICB9O1xuICB9LCAkbiA9ICh0LCBlLCByLCBuLCBhLCBpLCBzLCB1LCBjLCBoKSA9PiB7XG4gICAgZ3RbdF0uZmllbGRzLnB1c2goe1xuICAgICAgZmllbGROYW1lOiBGKGUpLFxuICAgICAgZ2V0dGVyUmV0dXJuVHlwZTogcixcbiAgICAgIGdldHRlcjogTChuLCBhKSxcbiAgICAgIGdldHRlckNvbnRleHQ6IGksXG4gICAgICBzZXR0ZXJBcmd1bWVudFR5cGU6IHMsXG4gICAgICBzZXR0ZXI6IEwodSwgYyksXG4gICAgICBzZXR0ZXJDb250ZXh0OiBoXG4gICAgfSk7XG4gIH0sIENuID0gKHQsIGUpID0+IHtcbiAgICBlID0gRihlKSwgaih0LCB7XG4gICAgICBpc1ZvaWQ6ICEwLFxuICAgICAgbmFtZTogZSxcbiAgICAgIGZyb21XaXJlVHlwZTogKCkgPT4ge1xuICAgICAgfSxcbiAgICAgIHRvV2lyZVR5cGU6IChyLCBuKSA9PiB7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIHp0ID0gW10sIFRuID0gKHQpID0+IHtcbiAgICB2YXIgZSA9IHp0Lmxlbmd0aDtcbiAgICByZXR1cm4genQucHVzaCh0KSwgZTtcbiAgfSwgRW4gPSAodCwgZSkgPT4ge1xuICAgIHZhciByID0gWlt0XTtcbiAgICByZXR1cm4gciA9PT0gdm9pZCAwICYmICQoYCR7ZX0gaGFzIHVua25vd24gdHlwZSAke3BlKHQpfWApLCByO1xuICB9LCBQbiA9ICh0LCBlKSA9PiB7XG4gICAgZm9yICh2YXIgciA9IG5ldyBBcnJheSh0KSwgbiA9IDA7IG4gPCB0OyArK24pXG4gICAgICByW25dID0gRW4oVFtlICsgbiAqIDQgPj4gMl0sIGBwYXJhbWV0ZXIgJHtufWApO1xuICAgIHJldHVybiByO1xuICB9LCBPbiA9ICh0LCBlLCByKSA9PiB7XG4gICAgdmFyIG4gPSBbXSwgYSA9IHQobiwgcik7XG4gICAgcmV0dXJuIG4ubGVuZ3RoICYmIChUW2UgPj4gMl0gPSBCLnRvSGFuZGxlKG4pKSwgYTtcbiAgfSwgX24gPSB7fSwgVGUgPSAodCkgPT4ge1xuICAgIHZhciBlID0gX25bdF07XG4gICAgcmV0dXJuIGUgPT09IHZvaWQgMCA/IEYodCkgOiBlO1xuICB9LCB4biA9ICh0LCBlLCByKSA9PiB7XG4gICAgdmFyIG4gPSA4LCBbYSwgLi4uaV0gPSBQbih0LCBlKSwgcyA9IGEudG9XaXJlVHlwZS5iaW5kKGEpLCB1ID0gaS5tYXAoKHkpID0+IHkucmVhZFZhbHVlRnJvbVBvaW50ZXIuYmluZCh5KSk7XG4gICAgdC0tO1xuICAgIHZhciBjID0gbmV3IEFycmF5KHQpLCBoID0gKHksIEMsIFAsIFMpID0+IHtcbiAgICAgIGZvciAodmFyIHggPSAwLCBPID0gMDsgTyA8IHQ7ICsrTylcbiAgICAgICAgY1tPXSA9IHVbT10oUyArIHgpLCB4ICs9IG47XG4gICAgICB2YXIgRTtcbiAgICAgIHN3aXRjaCAocikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgRSA9IEIudG9WYWx1ZSh5KS5hcHBseShudWxsLCBjKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIEUgPSBSZWZsZWN0LmNvbnN0cnVjdChCLnRvVmFsdWUoeSksIGMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgRSA9IGNbMF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBFID0gQi50b1ZhbHVlKHkpW1RlKEMpXSguLi5jKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBPbihzLCBQLCBFKTtcbiAgICB9LCBwID0gYG1ldGhvZENhbGxlcjwoJHtpLm1hcCgoeSkgPT4geS5uYW1lKX0pID0+ICR7YS5uYW1lfT5gO1xuICAgIHJldHVybiBUbihVdChwLCBoKSk7XG4gIH0sIFNuID0gKHQpID0+IHQgPyAodCA9IFRlKHQpLCBCLnRvSGFuZGxlKGdsb2JhbFRoaXNbdF0pKSA6IEIudG9IYW5kbGUoZ2xvYmFsVGhpcyksIEluID0gKHQpID0+IHtcbiAgICB0ID4gOSAmJiAoSlt0ICsgMV0gKz0gMSk7XG4gIH0sIERuID0gKHQsIGUsIHIsIG4sIGEpID0+IHp0W3RdKGUsIHIsIG4sIGEpLCBNbiA9ICh0KSA9PiB7XG4gICAgdmFyIGUgPSBCLnRvVmFsdWUodCk7XG4gICAgTHQoZSksIE50KHQpO1xuICB9LCBBbiA9ICh0LCBlLCByLCBuKSA9PiB7XG4gICAgdmFyIGEgPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldEZ1bGxZZWFyKCksIGkgPSBuZXcgRGF0ZShhLCAwLCAxKSwgcyA9IG5ldyBEYXRlKGEsIDYsIDEpLCB1ID0gaS5nZXRUaW1lem9uZU9mZnNldCgpLCBjID0gcy5nZXRUaW1lem9uZU9mZnNldCgpLCBoID0gTWF0aC5tYXgodSwgYyk7XG4gICAgVFt0ID4+IDJdID0gaCAqIDYwLCBvdFtlID4+IDJdID0gKyh1ICE9IGMpO1xuICAgIHZhciBwID0gKFApID0+IHtcbiAgICAgIHZhciBTID0gUCA+PSAwID8gXCItXCIgOiBcIitcIiwgeCA9IE1hdGguYWJzKFApLCBPID0gU3RyaW5nKE1hdGguZmxvb3IoeCAvIDYwKSkucGFkU3RhcnQoMiwgXCIwXCIpLCBFID0gU3RyaW5nKHggJSA2MCkucGFkU3RhcnQoMiwgXCIwXCIpO1xuICAgICAgcmV0dXJuIGBVVEMke1N9JHtPfSR7RX1gO1xuICAgIH0sIHkgPSBwKHUpLCBDID0gcChjKTtcbiAgICBjIDwgdSA/IChydCh5LCByLCAxNyksIHJ0KEMsIG4sIDE3KSkgOiAocnQoeSwgbiwgMTcpLCBydChDLCByLCAxNykpO1xuICB9LCBGbiA9ICgpID0+IDIxNDc0ODM2NDgsIFJuID0gKHQsIGUpID0+IE1hdGguY2VpbCh0IC8gZSkgKiBlLCBMbiA9ICh0KSA9PiB7XG4gICAgdmFyIGUgPSBQdC5idWZmZXIuYnl0ZUxlbmd0aCwgciA9ICh0IC0gZSArIDY1NTM1KSAvIDY1NTM2IHwgMDtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFB0Lmdyb3cociksIHJlKCksIDE7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9LCBqbiA9ICh0KSA9PiB7XG4gICAgdmFyIGUgPSBXLmxlbmd0aDtcbiAgICB0ID4+Pj0gMDtcbiAgICB2YXIgciA9IEZuKCk7XG4gICAgaWYgKHQgPiByKVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAodmFyIG4gPSAxOyBuIDw9IDQ7IG4gKj0gMikge1xuICAgICAgdmFyIGEgPSBlICogKDEgKyAwLjIgLyBuKTtcbiAgICAgIGEgPSBNYXRoLm1pbihhLCB0ICsgMTAwNjYzMjk2KTtcbiAgICAgIHZhciBpID0gTWF0aC5taW4ociwgUm4oTWF0aC5tYXgodCwgYSksIDY1NTM2KSksIHMgPSBMbihpKTtcbiAgICAgIGlmIChzKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfSwgR3QgPSB7fSwgQm4gPSAoKSA9PiBfIHx8IFwiLi90aGlzLnByb2dyYW1cIiwgY3QgPSAoKSA9PiB7XG4gICAgaWYgKCFjdC5zdHJpbmdzKSB7XG4gICAgICB2YXIgdCA9ICh0eXBlb2YgbmF2aWdhdG9yID09IFwib2JqZWN0XCIgJiYgbmF2aWdhdG9yLmxhbmd1YWdlIHx8IFwiQ1wiKS5yZXBsYWNlKFwiLVwiLCBcIl9cIikgKyBcIi5VVEYtOFwiLCBlID0ge1xuICAgICAgICBVU0VSOiBcIndlYl91c2VyXCIsXG4gICAgICAgIExPR05BTUU6IFwid2ViX3VzZXJcIixcbiAgICAgICAgUEFUSDogXCIvXCIsXG4gICAgICAgIFBXRDogXCIvXCIsXG4gICAgICAgIEhPTUU6IFwiL2hvbWUvd2ViX3VzZXJcIixcbiAgICAgICAgTEFORzogdCxcbiAgICAgICAgXzogQm4oKVxuICAgICAgfTtcbiAgICAgIGZvciAodmFyIHIgaW4gR3QpXG4gICAgICAgIEd0W3JdID09PSB2b2lkIDAgPyBkZWxldGUgZVtyXSA6IGVbcl0gPSBHdFtyXTtcbiAgICAgIHZhciBuID0gW107XG4gICAgICBmb3IgKHZhciByIGluIGUpXG4gICAgICAgIG4ucHVzaChgJHtyfT0ke2Vbcl19YCk7XG4gICAgICBjdC5zdHJpbmdzID0gbjtcbiAgICB9XG4gICAgcmV0dXJuIGN0LnN0cmluZ3M7XG4gIH0sIFVuID0gKHQsIGUpID0+IHtcbiAgICB2YXIgciA9IDAsIG4gPSAwO1xuICAgIGZvciAodmFyIGEgb2YgY3QoKSkge1xuICAgICAgdmFyIGkgPSBlICsgcjtcbiAgICAgIFRbdCArIG4gPj4gMl0gPSBpLCByICs9IHJ0KGEsIGksIDEgLyAwKSArIDEsIG4gKz0gNDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sIFZuID0gKHQsIGUpID0+IHtcbiAgICB2YXIgciA9IGN0KCk7XG4gICAgVFt0ID4+IDJdID0gci5sZW5ndGg7XG4gICAgdmFyIG4gPSAwO1xuICAgIGZvciAodmFyIGEgb2YgcilcbiAgICAgIG4gKz0gZ2UoYSkgKyAxO1xuICAgIHJldHVybiBUW2UgPj4gMl0gPSBuLCAwO1xuICB9LCBXbiA9ICh0KSA9PiA1MjtcbiAgZnVuY3Rpb24gSG4odCwgZSwgciwgbiwgYSkge1xuICAgIHJldHVybiA3MDtcbiAgfVxuICB2YXIga24gPSBbbnVsbCwgW10sIFtdXSwgTm4gPSAodCwgZSkgPT4ge1xuICAgIHZhciByID0ga25bdF07XG4gICAgZSA9PT0gMCB8fCBlID09PSAxMCA/ICgodCA9PT0gMSA/IG50IDogVikoJGUocikpLCByLmxlbmd0aCA9IDApIDogci5wdXNoKGUpO1xuICB9LCB6biA9ICh0LCBlLCByLCBuKSA9PiB7XG4gICAgZm9yICh2YXIgYSA9IDAsIGkgPSAwOyBpIDwgcjsgaSsrKSB7XG4gICAgICB2YXIgcyA9IFRbZSA+PiAyXSwgdSA9IFRbZSArIDQgPj4gMl07XG4gICAgICBlICs9IDg7XG4gICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHU7IGMrKylcbiAgICAgICAgTm4odCwgV1tzICsgY10pO1xuICAgICAgYSArPSB1O1xuICAgIH1cbiAgICByZXR1cm4gVFtuID4+IDJdID0gYSwgMDtcbiAgfSwgR24gPSAodCkgPT4gdDtcbiAgaWYgKEFyKCksIHpyKCksIGYubm9FeGl0UnVudGltZSAmJiBmLm5vRXhpdFJ1bnRpbWUsIGYucHJpbnQgJiYgKG50ID0gZi5wcmludCksIGYucHJpbnRFcnIgJiYgKFYgPSBmLnByaW50RXJyKSwgZi53YXNtQmluYXJ5ICYmIChxID0gZi53YXNtQmluYXJ5KSwgZi5hcmd1bWVudHMgJiYgZi5hcmd1bWVudHMsIGYudGhpc1Byb2dyYW0gJiYgKF8gPSBmLnRoaXNQcm9ncmFtKSwgZi5wcmVJbml0KVxuICAgIGZvciAodHlwZW9mIGYucHJlSW5pdCA9PSBcImZ1bmN0aW9uXCIgJiYgKGYucHJlSW5pdCA9IFtmLnByZUluaXRdKTsgZi5wcmVJbml0Lmxlbmd0aCA+IDA7IClcbiAgICAgIGYucHJlSW5pdC5zaGlmdCgpKCk7XG4gIHZhciBFZSwgeiwgWHQsIFBlLCB2LCBPZSwgX2UsIHhlLCBTZSwgSWUsIERlLCBNZSwgQWUsIFB0LCBGZTtcbiAgZnVuY3Rpb24gWG4odCkge1xuICAgIEVlID0gdC55YSwgeiA9IGYuX2ZyZWUgPSB0LnphLCBYdCA9IGYuX21hbGxvYyA9IHQuQmEsIFBlID0gdC5DYSwgdiA9IHQuRGEsIE9lID0gdC5FYSwgX2UgPSB0LkZhLCB4ZSA9IHQuR2EsIFNlID0gdC5IYSwgSWUgPSB0LklhLCBEZSA9IHQuSmEsIE4udmlpamlpID0gdC5LYSwgTWUgPSBOLmlpaWpqID0gdC5MYSwgTi5qaWppID0gdC5NYSwgQWUgPSBOLmppaWlpID0gdC5OYSwgTi5paWlpaWogPSB0Lk9hLCBOLmlpaWlpamogPSB0LlBhLCBOLmlpaWlpaWpqID0gdC5RYSwgUHQgPSB0LndhLCBGZSA9IHQuQWE7XG4gIH1cbiAgdmFyIHFuID0ge1xuICAgIHM6IHZyLFxuICAgIHc6IG1yLFxuICAgIGE6IGdyLFxuICAgIGo6IHdyLFxuICAgIG06IGJyLFxuICAgIFE6ICRyLFxuICAgIHA6IENyLFxuICAgIFU6IFRyLFxuICAgIGQ6IEVyLFxuICAgIGNhOiBQcixcbiAgICB0YTogX3IsXG4gICAgYmE6IHhyLFxuICAgIG9hOiBJcixcbiAgICByYTogWnIsXG4gICAgcWE6IEpyLFxuICAgIEg6IEtyLFxuICAgIG1hOiB0bixcbiAgICBYOiBybixcbiAgICBZOiBubixcbiAgICB4OiBvbixcbiAgICB0OiBzbixcbiAgICBzYTogY24sXG4gICAgbmE6IGhuLFxuICAgIFI6IHduLFxuICAgIEk6IGJuLFxuICAgIHVhOiAkbixcbiAgICBwYTogQ24sXG4gICAgTjogeG4sXG4gICAgdmE6IE50LFxuICAgIEQ6IFNuLFxuICAgIFM6IEluLFxuICAgIE06IERuLFxuICAgIGlhOiBNbixcbiAgICBkYTogQW4sXG4gICAgZ2E6IGpuLFxuICAgIGVhOiBVbixcbiAgICBmYTogVm4sXG4gICAgaGE6IFduLFxuICAgICQ6IEhuLFxuICAgIFY6IHpuLFxuICAgIEs6IG1hLFxuICAgIEM6IGJhLFxuICAgIFo6IGVhLFxuICAgIFQ6IE9hLFxuICAgIHI6IGRhLFxuICAgIGI6IEtuLFxuICAgIEU6IHZhLFxuICAgIGthOiBDYSxcbiAgICBjOiByYSxcbiAgICBqYTogVGEsXG4gICAgaDogdGEsXG4gICAgaTogb2EsXG4gICAgcTogY2EsXG4gICAgUDogeWEsXG4gICAgdjogZmEsXG4gICAgRjogaGEsXG4gICAgTDogcGEsXG4gICAgejogJGEsXG4gICAgSjogX2EsXG4gICAgYWE6IHhhLFxuICAgIF86IFNhLFxuICAgIGY6IG5hLFxuICAgIGw6IFluLFxuICAgIGU6IEpuLFxuICAgIGc6IFFuLFxuICAgIE86IFBhLFxuICAgIGs6IFpuLFxuICAgIGxhOiBnYSxcbiAgICBvOiBsYSxcbiAgICBCOiBpYSxcbiAgICB1OiB3YSxcbiAgICBXOiB1YSxcbiAgICBBOiBFYSxcbiAgICBuOiBhYSxcbiAgICBHOiBzYSxcbiAgICB5OiBHblxuICB9O1xuICBmdW5jdGlvbiBZbih0LCBlKSB7XG4gICAgdmFyIHIgPSBnKCk7XG4gICAgdHJ5IHtcbiAgICAgIHcodCkoZSk7XG4gICAgfSBjYXRjaCAobikge1xuICAgICAgaWYgKG0ociksIG4gIT09IG4gKyAwKSB0aHJvdyBuO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gWm4odCwgZSwgciwgbiwgYSkge1xuICAgIHZhciBpID0gZygpO1xuICAgIHRyeSB7XG4gICAgICB3KHQpKGUsIHIsIG4sIGEpO1xuICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgIGlmIChtKGkpLCBzICE9PSBzICsgMCkgdGhyb3cgcztcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIFFuKHQsIGUsIHIsIG4pIHtcbiAgICB2YXIgYSA9IGcoKTtcbiAgICB0cnkge1xuICAgICAgdyh0KShlLCByLCBuKTtcbiAgICB9IGNhdGNoIChpKSB7XG4gICAgICBpZiAobShhKSwgaSAhPT0gaSArIDApIHRocm93IGk7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBKbih0LCBlLCByKSB7XG4gICAgdmFyIG4gPSBnKCk7XG4gICAgdHJ5IHtcbiAgICAgIHcodCkoZSwgcik7XG4gICAgfSBjYXRjaCAoYSkge1xuICAgICAgaWYgKG0obiksIGEgIT09IGEgKyAwKSB0aHJvdyBhO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gS24odCwgZSkge1xuICAgIHZhciByID0gZygpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdyh0KShlKTtcbiAgICB9IGNhdGNoIChuKSB7XG4gICAgICBpZiAobShyKSwgbiAhPT0gbiArIDApIHRocm93IG47XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0YSh0LCBlLCByLCBuKSB7XG4gICAgdmFyIGEgPSBnKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB3KHQpKGUsIHIsIG4pO1xuICAgIH0gY2F0Y2ggKGkpIHtcbiAgICAgIGlmIChtKGEpLCBpICE9PSBpICsgMCkgdGhyb3cgaTtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGVhKHQsIGUsIHIsIG4sIGEsIGkpIHtcbiAgICB2YXIgcyA9IGcoKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHcodCkoZSwgciwgbiwgYSwgaSk7XG4gICAgfSBjYXRjaCAodSkge1xuICAgICAgaWYgKG0ocyksIHUgIT09IHUgKyAwKSB0aHJvdyB1O1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmEodCwgZSwgcikge1xuICAgIHZhciBuID0gZygpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdyh0KShlLCByKTtcbiAgICB9IGNhdGNoIChhKSB7XG4gICAgICBpZiAobShuKSwgYSAhPT0gYSArIDApIHRocm93IGE7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBuYSh0KSB7XG4gICAgdmFyIGUgPSBnKCk7XG4gICAgdHJ5IHtcbiAgICAgIHcodCkoKTtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICBpZiAobShlKSwgciAhPT0gciArIDApIHRocm93IHI7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhYSh0LCBlLCByLCBuLCBhLCBpLCBzLCB1LCBjLCBoLCBwKSB7XG4gICAgdmFyIHkgPSBnKCk7XG4gICAgdHJ5IHtcbiAgICAgIHcodCkoZSwgciwgbiwgYSwgaSwgcywgdSwgYywgaCwgcCk7XG4gICAgfSBjYXRjaCAoQykge1xuICAgICAgaWYgKG0oeSksIEMgIT09IEMgKyAwKSB0aHJvdyBDO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb2EodCwgZSwgciwgbiwgYSkge1xuICAgIHZhciBpID0gZygpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdyh0KShlLCByLCBuLCBhKTtcbiAgICB9IGNhdGNoIChzKSB7XG4gICAgICBpZiAobShpKSwgcyAhPT0gcyArIDApIHRocm93IHM7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpYSh0LCBlLCByLCBuLCBhLCBpLCBzKSB7XG4gICAgdmFyIHUgPSBnKCk7XG4gICAgdHJ5IHtcbiAgICAgIHcodCkoZSwgciwgbiwgYSwgaSwgcyk7XG4gICAgfSBjYXRjaCAoYykge1xuICAgICAgaWYgKG0odSksIGMgIT09IGMgKyAwKSB0aHJvdyBjO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2EodCwgZSwgciwgbiwgYSwgaSwgcywgdSwgYywgaCwgcCwgeSwgQywgUCwgUywgeCkge1xuICAgIHZhciBPID0gZygpO1xuICAgIHRyeSB7XG4gICAgICB3KHQpKGUsIHIsIG4sIGEsIGksIHMsIHUsIGMsIGgsIHAsIHksIEMsIFAsIFMsIHgpO1xuICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgIGlmIChtKE8pLCBFICE9PSBFICsgMCkgdGhyb3cgRTtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVhKHQsIGUsIHIsIG4sIGEsIGksIHMsIHUsIGMpIHtcbiAgICB2YXIgaCA9IGcoKTtcbiAgICB0cnkge1xuICAgICAgdyh0KShlLCByLCBuLCBhLCBpLCBzLCB1LCBjKTtcbiAgICB9IGNhdGNoIChwKSB7XG4gICAgICBpZiAobShoKSwgcCAhPT0gcCArIDApIHRocm93IHA7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjYSh0LCBlLCByLCBuLCBhLCBpKSB7XG4gICAgdmFyIHMgPSBnKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB3KHQpKGUsIHIsIG4sIGEsIGkpO1xuICAgIH0gY2F0Y2ggKHUpIHtcbiAgICAgIGlmIChtKHMpLCB1ICE9PSB1ICsgMCkgdGhyb3cgdTtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGxhKHQsIGUsIHIsIG4sIGEsIGkpIHtcbiAgICB2YXIgcyA9IGcoKTtcbiAgICB0cnkge1xuICAgICAgdyh0KShlLCByLCBuLCBhLCBpKTtcbiAgICB9IGNhdGNoICh1KSB7XG4gICAgICBpZiAobShzKSwgdSAhPT0gdSArIDApIHRocm93IHU7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBmYSh0LCBlLCByLCBuLCBhLCBpLCBzKSB7XG4gICAgdmFyIHUgPSBnKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB3KHQpKGUsIHIsIG4sIGEsIGksIHMpO1xuICAgIH0gY2F0Y2ggKGMpIHtcbiAgICAgIGlmIChtKHUpLCBjICE9PSBjICsgMCkgdGhyb3cgYztcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhKHQsIGUsIHIsIG4sIGEsIGksIHMsIHUpIHtcbiAgICB2YXIgYyA9IGcoKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHcodCkoZSwgciwgbiwgYSwgaSwgcywgdSk7XG4gICAgfSBjYXRjaCAoaCkge1xuICAgICAgaWYgKG0oYyksIGggIT09IGggKyAwKSB0aHJvdyBoO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGEodCkge1xuICAgIHZhciBlID0gZygpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdyh0KSgpO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIGlmIChtKGUpLCByICE9PSByICsgMCkgdGhyb3cgcjtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBhKHQsIGUsIHIsIG4sIGEsIGksIHMsIHUsIGMpIHtcbiAgICB2YXIgaCA9IGcoKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHcodCkoZSwgciwgbiwgYSwgaSwgcywgdSwgYyk7XG4gICAgfSBjYXRjaCAocCkge1xuICAgICAgaWYgKG0oaCksIHAgIT09IHAgKyAwKSB0aHJvdyBwO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24geWEodCwgZSwgciwgbiwgYSwgaSwgcykge1xuICAgIHZhciB1ID0gZygpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdyh0KShlLCByLCBuLCBhLCBpLCBzKTtcbiAgICB9IGNhdGNoIChjKSB7XG4gICAgICBpZiAobSh1KSwgYyAhPT0gYyArIDApIHRocm93IGM7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB2YSh0LCBlLCByLCBuKSB7XG4gICAgdmFyIGEgPSBnKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB3KHQpKGUsIHIsIG4pO1xuICAgIH0gY2F0Y2ggKGkpIHtcbiAgICAgIGlmIChtKGEpLCBpICE9PSBpICsgMCkgdGhyb3cgaTtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1hKHQsIGUsIHIsIG4pIHtcbiAgICB2YXIgYSA9IGcoKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHcodCkoZSwgciwgbik7XG4gICAgfSBjYXRjaCAoaSkge1xuICAgICAgaWYgKG0oYSksIGkgIT09IGkgKyAwKSB0aHJvdyBpO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2EodCwgZSwgciwgbiwgYSwgaSwgcywgdSkge1xuICAgIHZhciBjID0gZygpO1xuICAgIHRyeSB7XG4gICAgICB3KHQpKGUsIHIsIG4sIGEsIGksIHMsIHUpO1xuICAgIH0gY2F0Y2ggKGgpIHtcbiAgICAgIGlmIChtKGMpLCBoICE9PSBoICsgMCkgdGhyb3cgaDtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHdhKHQsIGUsIHIsIG4sIGEsIGksIHMsIHUpIHtcbiAgICB2YXIgYyA9IGcoKTtcbiAgICB0cnkge1xuICAgICAgdyh0KShlLCByLCBuLCBhLCBpLCBzLCB1KTtcbiAgICB9IGNhdGNoIChoKSB7XG4gICAgICBpZiAobShjKSwgaCAhPT0gaCArIDApIHRocm93IGg7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBiYSh0LCBlLCByLCBuLCBhLCBpKSB7XG4gICAgdmFyIHMgPSBnKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB3KHQpKGUsIHIsIG4sIGEsIGkpO1xuICAgIH0gY2F0Y2ggKHUpIHtcbiAgICAgIGlmIChtKHMpLCB1ICE9PSB1ICsgMCkgdGhyb3cgdTtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uICRhKHQsIGUsIHIsIG4sIGEsIGksIHMsIHUsIGMsIGgpIHtcbiAgICB2YXIgcCA9IGcoKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHcodCkoZSwgciwgbiwgYSwgaSwgcywgdSwgYywgaCk7XG4gICAgfSBjYXRjaCAoeSkge1xuICAgICAgaWYgKG0ocCksIHkgIT09IHkgKyAwKSB0aHJvdyB5O1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gQ2EodCwgZSwgcikge1xuICAgIHZhciBuID0gZygpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdyh0KShlLCByKTtcbiAgICB9IGNhdGNoIChhKSB7XG4gICAgICBpZiAobShuKSwgYSAhPT0gYSArIDApIHRocm93IGE7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBUYSh0LCBlLCByLCBuLCBhKSB7XG4gICAgdmFyIGkgPSBnKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB3KHQpKGUsIHIsIG4sIGEpO1xuICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgIGlmIChtKGkpLCBzICE9PSBzICsgMCkgdGhyb3cgcztcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIEVhKHQsIGUsIHIsIG4sIGEsIGksIHMsIHUsIGMsIGgpIHtcbiAgICB2YXIgcCA9IGcoKTtcbiAgICB0cnkge1xuICAgICAgdyh0KShlLCByLCBuLCBhLCBpLCBzLCB1LCBjLCBoKTtcbiAgICB9IGNhdGNoICh5KSB7XG4gICAgICBpZiAobShwKSwgeSAhPT0geSArIDApIHRocm93IHk7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBQYSh0LCBlLCByLCBuLCBhLCBpLCBzKSB7XG4gICAgdmFyIHUgPSBnKCk7XG4gICAgdHJ5IHtcbiAgICAgIHcodCkoZSwgciwgbiwgYSwgaSwgcyk7XG4gICAgfSBjYXRjaCAoYykge1xuICAgICAgaWYgKG0odSksIGMgIT09IGMgKyAwKSB0aHJvdyBjO1xuICAgICAgdigxLCAwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gT2EodCwgZSwgciwgbikge1xuICAgIHZhciBhID0gZygpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdyh0KShlLCByLCBuKTtcbiAgICB9IGNhdGNoIChpKSB7XG4gICAgICBpZiAobShhKSwgaSAhPT0gaSArIDApIHRocm93IGk7XG4gICAgICB2KDEsIDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfYSh0LCBlLCByLCBuLCBhLCBpLCBzLCB1LCBjLCBoLCBwLCB5KSB7XG4gICAgdmFyIEMgPSBnKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB3KHQpKGUsIHIsIG4sIGEsIGksIHMsIHUsIGMsIGgsIHAsIHkpO1xuICAgIH0gY2F0Y2ggKFApIHtcbiAgICAgIGlmIChtKEMpLCBQICE9PSBQICsgMCkgdGhyb3cgUDtcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHhhKHQsIGUsIHIsIG4sIGEsIGksIHMpIHtcbiAgICB2YXIgdSA9IGcoKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIE1lKHQsIGUsIHIsIG4sIGEsIGksIHMpO1xuICAgIH0gY2F0Y2ggKGMpIHtcbiAgICAgIGlmIChtKHUpLCBjICE9PSBjICsgMCkgdGhyb3cgYztcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIFNhKHQsIGUsIHIsIG4sIGEpIHtcbiAgICB2YXIgaSA9IGcoKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEFlKHQsIGUsIHIsIG4sIGEpO1xuICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgIGlmIChtKGkpLCBzICE9PSBzICsgMCkgdGhyb3cgcztcbiAgICAgIHYoMSwgMCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIElhKCkge1xuICAgIGFyKCk7XG4gICAgZnVuY3Rpb24gdCgpIHtcbiAgICAgIHZhciBlLCByO1xuICAgICAgZi5jYWxsZWRSdW4gPSAhMCwgIWh0ICYmIChvcigpLCAoZSA9IFF0KSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgfHwgZShmKSwgKHIgPSBmLm9uUnVudGltZUluaXRpYWxpemVkKSA9PT0gbnVsbCB8fCByID09PSB2b2lkIDAgfHwgci5jYWxsKGYpLCBpcigpKTtcbiAgICB9XG4gICAgZi5zZXRTdGF0dXMgPyAoZi5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gZi5zZXRTdGF0dXMoXCJcIiksIDEpLCB0KCk7XG4gICAgfSwgMSkpIDogdCgpO1xuICB9XG4gIHZhciBsdDtcbiAgcmV0dXJuIGx0ID0gYXdhaXQgZHIoKSwgSWEoKSwgZWUgPyBsID0gZiA6IGwgPSBuZXcgUHJvbWlzZSgodCwgZSkgPT4ge1xuICAgIFF0ID0gdCwgSnQgPSBlO1xuICB9KSwgbDtcbn1cbmZ1bmN0aW9uIHFlKG8pIHtcbiAgcmV0dXJuIFhlKFp0LCBvKTtcbn1cbmZ1bmN0aW9uIG1vKCkge1xuICByZXR1cm4gcWEoWnQpO1xufVxuZnVuY3Rpb24gZ28obykge1xuICBxZSh7XG4gICAgb3ZlcnJpZGVzOiBvLFxuICAgIGVxdWFsaXR5Rm46IE9iamVjdC5pcyxcbiAgICBmaXJlSW1tZWRpYXRlbHk6ICExXG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gWmEobywgbCkge1xuICByZXR1cm4gWWEoWnQsIG8sIGwpO1xufVxuY29uc3Qgd28gPSBcIjg1ZDQ2ZjU1ZDdjODZhNGQwOWJiMDQyNzMzNjc0MDhiMTljMzI0ZjU4MmQwNDBkMDE4YWVjYjI1YTlhODI5NDJcIiwgWWUgPSBbXG4gIFtcImF6dGVjXCIsIFwiQXp0ZWNcIl0sXG4gIFtcImNvZGVfMTI4XCIsIFwiQ29kZTEyOFwiXSxcbiAgW1wiY29kZV8zOVwiLCBcIkNvZGUzOVwiXSxcbiAgW1wiY29kZV85M1wiLCBcIkNvZGU5M1wiXSxcbiAgW1wiY29kYWJhclwiLCBcIkNvZGFiYXJcIl0sXG4gIFtcImRhdGFiYXJcIiwgXCJEYXRhQmFyXCJdLFxuICBbXCJkYXRhYmFyX2V4cGFuZGVkXCIsIFwiRGF0YUJhckV4cGFuZGVkXCJdLFxuICBbXCJkYXRhYmFyX2xpbWl0ZWRcIiwgXCJEYXRhQmFyTGltaXRlZFwiXSxcbiAgW1wiZGF0YV9tYXRyaXhcIiwgXCJEYXRhTWF0cml4XCJdLFxuICBbXCJkeF9maWxtX2VkZ2VcIiwgXCJEWEZpbG1FZGdlXCJdLFxuICBbXCJlYW5fMTNcIiwgXCJFQU4tMTNcIl0sXG4gIFtcImVhbl84XCIsIFwiRUFOLThcIl0sXG4gIFtcIml0ZlwiLCBcIklURlwiXSxcbiAgW1wibWF4aV9jb2RlXCIsIFwiTWF4aUNvZGVcIl0sXG4gIFtcIm1pY3JvX3FyX2NvZGVcIiwgXCJNaWNyb1FSQ29kZVwiXSxcbiAgW1wicGRmNDE3XCIsIFwiUERGNDE3XCJdLFxuICBbXCJxcl9jb2RlXCIsIFwiUVJDb2RlXCJdLFxuICBbXCJybV9xcl9jb2RlXCIsIFwick1RUkNvZGVcIl0sXG4gIFtcInVwY19hXCIsIFwiVVBDLUFcIl0sXG4gIFtcInVwY19lXCIsIFwiVVBDLUVcIl0sXG4gIFtcImxpbmVhcl9jb2Rlc1wiLCBcIkxpbmVhci1Db2Rlc1wiXSxcbiAgW1wibWF0cml4X2NvZGVzXCIsIFwiTWF0cml4LUNvZGVzXCJdLFxuICBbXCJhbnlcIiwgXCJBbnlcIl1cbl0sIFFhID0gWy4uLlllLCBbXCJ1bmtub3duXCJdXS5tYXAoKG8pID0+IG9bMF0pLCBZdCA9IG5ldyBNYXAoXG4gIFllXG4pO1xuZnVuY3Rpb24gSmEobykge1xuICBmb3IgKGNvbnN0IFtsLCBkXSBvZiBZdClcbiAgICBpZiAobyA9PT0gZClcbiAgICAgIHJldHVybiBsO1xuICByZXR1cm4gXCJ1bmtub3duXCI7XG59XG5mdW5jdGlvbiBLYShvKSB7XG4gIGlmIChaZShvKSlcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IG8ubmF0dXJhbFdpZHRoLFxuICAgICAgaGVpZ2h0OiBvLm5hdHVyYWxIZWlnaHRcbiAgICB9O1xuICBpZiAoUWUobykpXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBvLndpZHRoLmJhc2VWYWwudmFsdWUsXG4gICAgICBoZWlnaHQ6IG8uaGVpZ2h0LmJhc2VWYWwudmFsdWVcbiAgICB9O1xuICBpZiAoSmUobykpXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBvLnZpZGVvV2lkdGgsXG4gICAgICBoZWlnaHQ6IG8udmlkZW9IZWlnaHRcbiAgICB9O1xuICBpZiAodHIobykpXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBvLndpZHRoLFxuICAgICAgaGVpZ2h0OiBvLmhlaWdodFxuICAgIH07XG4gIGlmIChycihvKSlcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IG8uZGlzcGxheVdpZHRoLFxuICAgICAgaGVpZ2h0OiBvLmRpc3BsYXlIZWlnaHRcbiAgICB9O1xuICBpZiAoS2UobykpXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBvLndpZHRoLFxuICAgICAgaGVpZ2h0OiBvLmhlaWdodFxuICAgIH07XG4gIGlmIChlcihvKSlcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IG8ud2lkdGgsXG4gICAgICBoZWlnaHQ6IG8uaGVpZ2h0XG4gICAgfTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICBcIlRoZSBwcm92aWRlZCB2YWx1ZSBpcyBub3Qgb2YgdHlwZSAnKEJsb2Igb3IgSFRNTENhbnZhc0VsZW1lbnQgb3IgSFRNTEltYWdlRWxlbWVudCBvciBIVE1MVmlkZW9FbGVtZW50IG9yIEltYWdlQml0bWFwIG9yIEltYWdlRGF0YSBvciBPZmZzY3JlZW5DYW52YXMgb3IgU1ZHSW1hZ2VFbGVtZW50IG9yIFZpZGVvRnJhbWUpJy5cIlxuICApO1xufVxuZnVuY3Rpb24gWmUobykge1xuICB2YXIgbCwgZDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbyBpbnN0YW5jZW9mICgoZCA9IChsID0gbyA9PSBudWxsID8gdm9pZCAwIDogby5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogbC5kZWZhdWx0VmlldykgPT0gbnVsbCA/IHZvaWQgMCA6IGQuSFRNTEltYWdlRWxlbWVudCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24gUWUobykge1xuICB2YXIgbCwgZDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbyBpbnN0YW5jZW9mICgoZCA9IChsID0gbyA9PSBudWxsID8gdm9pZCAwIDogby5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogbC5kZWZhdWx0VmlldykgPT0gbnVsbCA/IHZvaWQgMCA6IGQuU1ZHSW1hZ2VFbGVtZW50KTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBKZShvKSB7XG4gIHZhciBsLCBkO1xuICB0cnkge1xuICAgIHJldHVybiBvIGluc3RhbmNlb2YgKChkID0gKGwgPSBvID09IG51bGwgPyB2b2lkIDAgOiBvLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBsLmRlZmF1bHRWaWV3KSA9PSBudWxsID8gdm9pZCAwIDogZC5IVE1MVmlkZW9FbGVtZW50KTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBLZShvKSB7XG4gIHZhciBsLCBkO1xuICB0cnkge1xuICAgIHJldHVybiBvIGluc3RhbmNlb2YgKChkID0gKGwgPSBvID09IG51bGwgPyB2b2lkIDAgOiBvLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBsLmRlZmF1bHRWaWV3KSA9PSBudWxsID8gdm9pZCAwIDogZC5IVE1MQ2FudmFzRWxlbWVudCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24gdHIobykge1xuICB0cnkge1xuICAgIHJldHVybiBvIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSBcIltvYmplY3QgSW1hZ2VCaXRtYXBdXCI7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24gZXIobykge1xuICB0cnkge1xuICAgIHJldHVybiBvIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gXCJbb2JqZWN0IE9mZnNjcmVlbkNhbnZhc11cIjtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBycihvKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG8gaW5zdGFuY2VvZiBWaWRlb0ZyYW1lIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gXCJbb2JqZWN0IFZpZGVvRnJhbWVdXCI7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24gdG8obykge1xuICB0cnkge1xuICAgIHJldHVybiBvIGluc3RhbmNlb2YgQmxvYiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBCbG9iXVwiO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmZ1bmN0aW9uIGVvKG8pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbyBpbnN0YW5jZW9mIEltYWdlRGF0YSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBJbWFnZURhdGFdXCI7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24gcm8obywgbCkge1xuICB0cnkge1xuICAgIGNvbnN0IGQgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKG8sIGwpO1xuICAgIGlmIChkLmdldENvbnRleHQoXCIyZFwiKSBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRClcbiAgICAgIHJldHVybiBkO1xuICAgIHRocm93IHZvaWQgMDtcbiAgfSBjYXRjaCB7XG4gICAgY29uc3QgZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgcmV0dXJuIGQud2lkdGggPSBvLCBkLmhlaWdodCA9IGwsIGQ7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIG5yKG8pIHtcbiAgaWYgKFplKG8pICYmICFhd2FpdCBpbyhvKSlcbiAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgXCJGYWlsZWQgdG8gbG9hZCBvciBkZWNvZGUgSFRNTEltYWdlRWxlbWVudC5cIixcbiAgICAgIFwiSW52YWxpZFN0YXRlRXJyb3JcIlxuICAgICk7XG4gIGlmIChRZShvKSAmJiAhYXdhaXQgc28obykpXG4gICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcbiAgICAgIFwiRmFpbGVkIHRvIGxvYWQgb3IgZGVjb2RlIFNWR0ltYWdlRWxlbWVudC5cIixcbiAgICAgIFwiSW52YWxpZFN0YXRlRXJyb3JcIlxuICAgICk7XG4gIGlmIChycihvKSAmJiB1byhvKSlcbiAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiVmlkZW9GcmFtZSBpcyBjbG9zZWQuXCIsIFwiSW52YWxpZFN0YXRlRXJyb3JcIik7XG4gIGlmIChKZShvKSAmJiAoby5yZWFkeVN0YXRlID09PSAwIHx8IG8ucmVhZHlTdGF0ZSA9PT0gMSkpXG4gICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIkludmFsaWQgZWxlbWVudCBvciBzdGF0ZS5cIiwgXCJJbnZhbGlkU3RhdGVFcnJvclwiKTtcbiAgaWYgKHRyKG8pICYmIGxvKG8pKVxuICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXG4gICAgICBcIlRoZSBpbWFnZSBzb3VyY2UgaXMgZGV0YWNoZWQuXCIsXG4gICAgICBcIkludmFsaWRTdGF0ZUVycm9yXCJcbiAgICApO1xuICBjb25zdCB7IHdpZHRoOiBsLCBoZWlnaHQ6IGQgfSA9IEthKG8pO1xuICBpZiAobCA9PT0gMCB8fCBkID09PSAwKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBmID0gcm8obCwgZCkuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBmLmRyYXdJbWFnZShvLCAwLCAwKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZi5nZXRJbWFnZURhdGEoMCwgMCwgbCwgZCk7XG4gIH0gY2F0Y2gge1xuICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJTb3VyY2Ugd291bGQgdGFpbnQgb3JpZ2luLlwiLCBcIlNlY3VyaXR5RXJyb3JcIik7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIG5vKG8pIHtcbiAgbGV0IGw7XG4gIHRyeSB7XG4gICAgbCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKG8pO1xuICB9IGNhdGNoIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGdsb2JhbFRoaXMuSW1hZ2UpIHtcbiAgICAgICAgbCA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBsZXQgZiA9IFwiXCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwobyksIGwuc3JjID0gZiwgYXdhaXQgbC5kZWNvZGUoKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGYpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgICBcIkZhaWxlZCB0byBsb2FkIG9yIGRlY29kZSBCbG9iLlwiLFxuICAgICAgICBcIkludmFsaWRTdGF0ZUVycm9yXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhd2FpdCBucihsKTtcbn1cbmZ1bmN0aW9uIGFvKG8pIHtcbiAgY29uc3QgeyB3aWR0aDogbCwgaGVpZ2h0OiBkIH0gPSBvO1xuICBpZiAobCA9PT0gMCB8fCBkID09PSAwKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBiID0gby5nZXRDb250ZXh0KFwiMmRcIik7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGIuZ2V0SW1hZ2VEYXRhKDAsIDAsIGwsIGQpO1xuICB9IGNhdGNoIHtcbiAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiU291cmNlIHdvdWxkIHRhaW50IG9yaWdpbi5cIiwgXCJTZWN1cml0eUVycm9yXCIpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBvbyhvKSB7XG4gIGlmICh0byhvKSlcbiAgICByZXR1cm4gYXdhaXQgbm8obyk7XG4gIGlmIChlbyhvKSkge1xuICAgIGlmIChjbyhvKSlcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXG4gICAgICAgIFwiVGhlIGltYWdlIGRhdGEgaGFzIGJlZW4gZGV0YWNoZWQuXCIsXG4gICAgICAgIFwiSW52YWxpZFN0YXRlRXJyb3JcIlxuICAgICAgKTtcbiAgICByZXR1cm4gbztcbiAgfVxuICByZXR1cm4gS2UobykgfHwgZXIobykgPyBhbyhvKSA6IGF3YWl0IG5yKG8pO1xufVxuYXN5bmMgZnVuY3Rpb24gaW8obykge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBvLmRlY29kZSgpLCAhMDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBzbyhvKSB7XG4gIHZhciBsO1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCAoKGwgPSBvLmRlY29kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGwuY2FsbChvKSksICEwO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmZ1bmN0aW9uIHVvKG8pIHtcbiAgcmV0dXJuIG8uZm9ybWF0ID09PSBudWxsO1xufVxuZnVuY3Rpb24gY28obykge1xuICByZXR1cm4gby5kYXRhLmJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwO1xufVxuZnVuY3Rpb24gbG8obykge1xuICByZXR1cm4gby53aWR0aCA9PT0gMCAmJiBvLmhlaWdodCA9PT0gMDtcbn1cbmZ1bmN0aW9uIEdlKG8sIGwpIHtcbiAgcmV0dXJuIGZvKG8pID8gbmV3IERPTUV4Y2VwdGlvbihgJHtsfTogJHtvLm1lc3NhZ2V9YCwgby5uYW1lKSA6IGhvKG8pID8gbmV3IG8uY29uc3RydWN0b3IoYCR7bH06ICR7by5tZXNzYWdlfWApIDogbmV3IEVycm9yKGAke2x9OiAke299YCk7XG59XG5mdW5jdGlvbiBmbyhvKSB7XG4gIHJldHVybiBvIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gXCJbb2JqZWN0IERPTUV4Y2VwdGlvbl1cIjtcbn1cbmZ1bmN0aW9uIGhvKG8pIHtcbiAgcmV0dXJuIG8gaW5zdGFuY2VvZiBFcnJvciB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykgPT09IFwiW29iamVjdCBFcnJvcl1cIjtcbn1cbnZhciBmdDtcbmNsYXNzIGJvIHtcbiAgY29uc3RydWN0b3IobCA9IHt9KSB7XG4gICAgSGUodGhpcywgZnQpO1xuICAgIHZhciBkO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBiID0gKGQgPSBsID09IG51bGwgPyB2b2lkIDAgOiBsLmZvcm1hdHMpID09IG51bGwgPyB2b2lkIDAgOiBkLmZpbHRlcihcbiAgICAgICAgKGYpID0+IGYgIT09IFwidW5rbm93blwiXG4gICAgICApO1xuICAgICAgaWYgKChiID09IG51bGwgPyB2b2lkIDAgOiBiLmxlbmd0aCkgPT09IDApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJIaW50IG9wdGlvbiBwcm92aWRlZCwgYnV0IGlzIGVtcHR5LlwiKTtcbiAgICAgIGZvciAoY29uc3QgZiBvZiBiICE9IG51bGwgPyBiIDogW10pXG4gICAgICAgIGlmICghWXQuaGFzKGYpKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIHJlYWQgdGhlICdmb3JtYXRzJyBwcm9wZXJ0eSBmcm9tICdCYXJjb2RlRGV0ZWN0b3JPcHRpb25zJzogVGhlIHByb3ZpZGVkIHZhbHVlICcke2Z9JyBpcyBub3QgYSB2YWxpZCBlbnVtIHZhbHVlIG9mIHR5cGUgQmFyY29kZUZvcm1hdC5gXG4gICAgICAgICAgKTtcbiAgICAgIGtlKHRoaXMsIGZ0LCBiICE9IG51bGwgPyBiIDogW10pLCBxZSh7IGZpcmVJbW1lZGlhdGVseTogITAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoYikge1xuICAgICAgdGhyb3cgR2UoXG4gICAgICAgIGIsXG4gICAgICAgIFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnQmFyY29kZURldGVjdG9yJ1wiXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgYXN5bmMgZ2V0U3VwcG9ydGVkRm9ybWF0cygpIHtcbiAgICByZXR1cm4gUWEuZmlsdGVyKChsKSA9PiBsICE9PSBcInVua25vd25cIik7XG4gIH1cbiAgYXN5bmMgZGV0ZWN0KGwpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZCA9IGF3YWl0IG9vKGwpO1xuICAgICAgaWYgKGQgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIGxldCBiO1xuICAgICAgY29uc3QgZiA9IHtcbiAgICAgICAgdHJ5Q29kZTM5RXh0ZW5kZWRNb2RlOiAhMSxcbiAgICAgICAgdGV4dE1vZGU6IFwiUGxhaW5cIixcbiAgICAgICAgZm9ybWF0czogV2UodGhpcywgZnQpLm1hcCgoSSkgPT4gWXQuZ2V0KEkpKVxuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGIgPSBhd2FpdCBaYShkLCBmKTtcbiAgICAgIH0gY2F0Y2ggKEkpIHtcbiAgICAgICAgdGhyb3cgY29uc29sZS5lcnJvcihJKSwgbmV3IERPTUV4Y2VwdGlvbihcbiAgICAgICAgICBcIkJhcmNvZGUgZGV0ZWN0aW9uIHNlcnZpY2UgdW5hdmFpbGFibGUuXCIsXG4gICAgICAgICAgXCJOb3RTdXBwb3J0ZWRFcnJvclwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYi5tYXAoKEkpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHRvcExlZnQ6IHsgeDogRCwgeTogTSB9LFxuICAgICAgICAgIHRvcFJpZ2h0OiB7IHg6IF8sIHk6IEEgfSxcbiAgICAgICAgICBib3R0b21MZWZ0OiB7IHg6IFUsIHk6IEcgfSxcbiAgICAgICAgICBib3R0b21SaWdodDogeyB4OiB0dCwgeTogWCB9XG4gICAgICAgIH0gPSBJLnBvc2l0aW9uLCBudCA9IE1hdGgubWluKEQsIF8sIFUsIHR0KSwgViA9IE1hdGgubWluKE0sIEEsIEcsIFgpLCBxID0gTWF0aC5tYXgoRCwgXywgVSwgdHQpLCBodCA9IE1hdGgubWF4KE0sIEEsIEcsIFgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJvdW5kaW5nQm94OiBuZXcgRE9NUmVjdFJlYWRPbmx5KFxuICAgICAgICAgICAgbnQsXG4gICAgICAgICAgICBWLFxuICAgICAgICAgICAgcSAtIG50LFxuICAgICAgICAgICAgaHQgLSBWXG4gICAgICAgICAgKSxcbiAgICAgICAgICByYXdWYWx1ZTogSS50ZXh0LFxuICAgICAgICAgIGZvcm1hdDogSmEoSS5mb3JtYXQpLFxuICAgICAgICAgIGNvcm5lclBvaW50czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiBELFxuICAgICAgICAgICAgICB5OiBNXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiBfLFxuICAgICAgICAgICAgICB5OiBBXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiB0dCxcbiAgICAgICAgICAgICAgeTogWFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDogVSxcbiAgICAgICAgICAgICAgeTogR1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGQpIHtcbiAgICAgIHRocm93IEdlKFxuICAgICAgICBkLFxuICAgICAgICBcIkZhaWxlZCB0byBleGVjdXRlICdkZXRlY3QnIG9uICdCYXJjb2RlRGV0ZWN0b3InXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5mdCA9IG5ldyBXZWFrTWFwKCk7XG5leHBvcnQge1xuICBibyBhcyBCYXJjb2RlRGV0ZWN0b3IsXG4gIHZvIGFzIFpYSU5HX0NQUF9DT01NSVQsXG4gIHdvIGFzIFpYSU5HX1dBU01fU0hBMjU2LFxuICB5byBhcyBaWElOR19XQVNNX1ZFUlNJT04sXG4gIHFlIGFzIHByZXBhcmVaWGluZ01vZHVsZSxcbiAgbW8gYXMgcHVyZ2VaWGluZ01vZHVsZSxcbiAgZ28gYXMgc2V0WlhpbmdNb2R1bGVPdmVycmlkZXNcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/barcode-detector/dist/es/ponyfill.js\n");

/***/ })

};
;